{"version":3,"sources":["constantes/constantes.js","Logic/Controls.js","Display/Bloc.js","constantes/utilities.js","Display/Windows.js","Logic/Algo/Automaton.js","Logic/Algo/GameOfLife.js","Logic/Algo/ColoredVariant.js","Logic/CellularGame.js","App.js","serviceWorker.js","index.js"],"names":["GAME_OF_LIFE","COLORED_VARIANT","TYPE_SIMULATION","CONWAY","DAY_NIGHT","HIGHLIFE","TYPE_GAME_OF_LIFE","INIT_CONTROLS","speed","type","options","variant","nbStates","play","INIT_WINDOWS","click","cells","Map","INIT_CORE","nbR","nbC","size","BUTTON_COLOR","MARGIN_BUTTONS","Controls","updateValueSpecific","event","stateTarget","nextState","props","specific","get","value","target","set","updateValuesCore","core","updateValuesOptionsAutomaton","nextOptions","playPauseButton","message","className","onClick","array","map","el","key","this","displayOptionsConway","displayOptionsImmigration","id","onChange","displayOptionsFromList","min","max","step","onSubmit","e","preventDefault","clear","randomCells","displayAutomatonOptions","React","Component","Bloc","console","error","position","indR","indC","styles","height","width","handleClic","onMouseEnter","handleEnter","createClass","style","getKeyFromCoordinates","r","c","getValueCell","undefined","Windows","handleEnterNewBloc","changeValueCell","handleUserClicInsideBloc","arrayBlocs","tmpRow","push","displayBlocs","Automaton","nMap","Math","floor","random","cValue","cKey","forEach","i","length","parseInt","getCoordinatesFromKey","rules","delete","values","s","checkValue","next","vToCheck","compt","GameOfLife","fNext","rulesConway","rulesDayNight","rulesHighLife","cellValue","neighbour","countNeighbours","cState","nbDeadN","ColoredVariant","currentState","changeValue","CellularGame","stopAnimation","animation","clearInterval","startAnimation","setInterval","stepAutomaton","state","controls","changeValueAnimation","handlePlayPause","getStateControls","setStateControls","initAutomaton","automaton","windows","checkCells","clearCells","nextStateWindows","getStateWindows","setStateWindows","getNewValue","stateWindows","newState","emptyCells","setState","randomBoard","setStateCore","newCore","callBack","newWindows","newControls","getCoreState","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.0171aaad.chunk.js","sourcesContent":["// Constants use for the name of the automaton\nexport const GAME_OF_LIFE = \"Jeu de la Vie\";\nexport const COLORED_VARIANT = \"Variante colorée\";\n\nexport const TYPE_SIMULATION = [GAME_OF_LIFE, COLORED_VARIANT]; // All the simulation implemented\n\n// Variant of the game of life\nexport const CONWAY = \"Conway: Jeu de la Vie\";\nexport const DAY_NIGHT = \"Day & Night\";\nexport const HIGHLIFE = \"HighLife\";\n\nexport const TYPE_GAME_OF_LIFE = [CONWAY, DAY_NIGHT, HIGHLIFE];\n\nconst DEFAULT_SIMULATION = 0; // Number of the default simulation\n\nexport const INIT_CONTROLS = {\n  // Initial state of the controls section\n  speed: 500, // Speed of the animation in ms\n  type: TYPE_SIMULATION[DEFAULT_SIMULATION], // Type of the simulation (ie automaton)\n  options: {\n    // Use for game of lige\n    variant: TYPE_GAME_OF_LIFE[0],\n    // Use for Colored Life\n    nbStates: 3\n  }, // Options specific to the automaton\n  play: false // true is the animation is set to play\n};\n\nexport const INIT_WINDOWS = {\n  // Initial state of the windows section\n  click: false, // To handle when the user click\n  cells: new Map() // represent the board. Map with String has key and int as value\n};\n\nexport const INIT_CORE = {\n  // Initial state of the core section (ie common to all sections)\n  nbR: 20, // Number of rows\n  nbC: 20, // Number of columns\n  size: 15 // Size of the blocs\n};\n\nexport const NB_COLORS = 8; // Number of colors set in the CSS\n\n/* Buttons */\n\nexport const BUTTON_COLOR = \"btn-success\"; // Bootstrap of the button\n","import React from \"react\";\n\nimport {\n  TYPE_SIMULATION,\n  BUTTON_COLOR,\n  NB_COLORS,\n  TYPE_GAME_OF_LIFE,\n  /* Use to display options of the automaton */\n  GAME_OF_LIFE,\n  COLORED_VARIANT\n} from \"../constantes/constantes\";\n\nconst MARGIN_BUTTONS = 1; // Value of the margin X for the buttons\n\nexport default class Controls extends React.Component {\n  displayOptionsFromList(array) {\n    // Display the differents options from a list\n    // The key of the element are the name of the element\n    return array.map(el => <option key={el}>{el}</option>);\n  }\n\n  updateValueSpecific = (event, stateTarget) => {\n    // update the state specific to controls\n    let nextState = { ...this.props.specific.get() }; // Copy of the state\n    // Used in parent to compare\n    const value = event.target.value;\n\n    nextState[stateTarget] = value;\n\n    this.props.specific.set(nextState);\n  };\n\n  updateValuesCore = (event, stateTarget) => {\n    // update the state core\n    let nextState = { ...this.props.core.get() }; // Copy of the state\n    // Used in parent to compare\n    const value = event.target.value;\n\n    nextState[stateTarget] = value;\n\n    this.props.core.set(nextState);\n  };\n\n  updateValuesOptionsAutomaton = (event, stateTarget) => {\n    // update the state specific to the options of the automaton\n    let nextState = { ...this.props.specific.get() }; // Copy of the state\n    let nextOptions = { ...nextState.options };\n\n    // Used in parent to compare\n    const value = event.target.value;\n\n    nextOptions[stateTarget] = value;\n    nextState.options = nextOptions;\n\n    this.props.specific.set(nextState);\n  };\n\n  playPauseButton = () => {\n    let message = \"Play\";\n    const { play } = this.props.specific.get();\n    if (play) {\n      message = \"Pause\";\n    }\n    return (\n      <button\n        type=\"button\"\n        className={`btn ${BUTTON_COLOR} mx-${MARGIN_BUTTONS} col`}\n        onClick={() => this.props.play()}\n      >\n        {message}\n      </button>\n    );\n  };\n\n  displayAutomatonOptions() {\n    const AUTOMATON = this.props.specific.get().type;\n    switch (AUTOMATON) {\n      case GAME_OF_LIFE:\n        return this.displayOptionsConway();\n      case COLORED_VARIANT:\n        return this.displayOptionsImmigration();\n      default:\n        break;\n    }\n  }\n\n  displayOptionsConway() {\n    // Options for the game of life\n    const { variant } = this.props.specific.get().options; // all the options of the game\n    return (\n      <div id=\"OptionsConway\">\n        <hr />\n        <h3>Jeu de la vie</h3>\n        <div className=\"form-group\">\n          <label>Variante du Jeu de la Vie</label>\n          <select\n            className=\"form-control\"\n            value={variant}\n            onChange={event =>\n              this.updateValuesOptionsAutomaton(event, \"variant\")\n            }\n          >\n            {this.displayOptionsFromList(TYPE_GAME_OF_LIFE)}\n          </select>\n        </div>\n      </div>\n    );\n  }\n\n  displayOptionsImmigration() {\n    // Options for the Immigration game\n\n    const { nbStates } = this.props.specific.get().options; // all the options of the game\n    return (\n      <div id=\"OptionsImmigration\">\n        <hr />\n        <h3>Jeu de l'Immigration</h3>\n\n        <div className=\"form-group\">\n          <label>Nombre d'états: {nbStates}</label>\n          <input\n            className=\"form-control\"\n            type=\"range\"\n            value={nbStates}\n            min=\"3\"\n            max={NB_COLORS}\n            step=\"1\"\n            onChange={event =>\n              this.updateValuesOptionsAutomaton(event, \"nbStates\")\n            }\n          />\n        </div>\n      </div>\n    );\n  }\n\n  render() {\n    const { speed, type } = this.props.specific.get();\n    const { size, nbC, nbR } = this.props.core.get();\n\n    return (\n      <form\n        onSubmit={e => e.preventDefault()} // Avoid the submit when click on button\n      >\n        <hr />\n        <h3>Gestion de l'automate</h3>\n\n        <div className=\"row no-gutters justify-content-between align-items-center\">\n          <div id=\"AutomatonSelection\" className=\"form-group col-5\">\n            <label>Type d'automate</label>\n            <select\n              className=\"form-control\"\n              value={type}\n              onChange={event => this.updateValueSpecific(event, \"type\")}\n            >\n              {this.displayOptionsFromList(TYPE_SIMULATION)}\n            </select>\n          </div>\n          <div className=\"row col-6\">\n            <button\n              type=\"button\"\n              className={`btn ${BUTTON_COLOR} mx-${MARGIN_BUTTONS} col`}\n              onClick={() => this.props.clear()}\n            >\n              Vider\n            </button>\n            <button\n              type=\"button\"\n              className={`btn ${BUTTON_COLOR} mx-${MARGIN_BUTTONS} col`}\n              onClick={() => this.props.randomCells()}\n            >\n              Aléatoire\n            </button>\n          </div>\n        </div>\n\n        {this.displayAutomatonOptions()}\n\n        <hr />\n        <h3>Gestion de l'affichage</h3>\n\n        <div className=\"row\">\n          <div className=\"form-group col-4\">\n            <label>Lignes: {nbR}</label>\n            <input\n              className=\"form-control-range\"\n              type=\"range\"\n              value={nbR}\n              min=\"1\"\n              max=\"100\"\n              step=\"1\"\n              onChange={event => this.updateValuesCore(event, \"nbR\")}\n            />\n          </div>\n          <div className=\"form-group col-4\">\n            <label>Colonnes: {nbC}</label>\n            <input\n              className=\"form-control-range\"\n              type=\"range\"\n              value={nbC}\n              min=\"1\"\n              max=\"100\"\n              step=\"1\"\n              onChange={event => this.updateValuesCore(event, \"nbC\")}\n            />\n          </div>\n          <div className=\"form-group col-4\">\n            <label>Taille: {size}</label>\n            <input\n              className=\"form-control-range\"\n              type=\"range\"\n              value={size}\n              min=\"5\"\n              max=\"50\"\n              step=\"1\"\n              onChange={event => this.updateValuesCore(event, \"size\")}\n            />\n          </div>\n        </div>\n\n        <hr />\n        <h3>Gestion de la simulation</h3>\n\n        <div className=\"row no-gutters justify-content-between align-items-center\">\n          <div id=\"SpeedSelection\" className=\"form-group col-5\">\n            <label>Vitesse {speed / 1000}s</label>\n\n            <input\n              className=\"form-control-range\"\n              type=\"range\"\n              value={speed}\n              min=\"100\"\n              max=\"1000\"\n              step=\"100\"\n              onChange={event => this.updateValueSpecific(event, \"speed\")}\n            />\n          </div>\n          <div id=\"buttonsRow\" className=\"row col-6\">\n            {this.playPauseButton()}\n            <button\n              type=\"button\"\n              className={`btn ${BUTTON_COLOR} mx-${MARGIN_BUTTONS} col`}\n              onClick={() => this.props.step()}\n            >\n              Step\n            </button>\n          </div>\n        </div>\n      </form>\n    );\n  }\n}\n","import React from \"react\";\nimport \"./Bloc.css\";\n\nimport { NB_COLORS } from \"../constantes/constantes\";\n\nexport default class Bloc extends React.Component {\n  createClass() {\n    // Change the class of the bloc\n    const value = this.props.value;\n    if (0 <= value && value < NB_COLORS) {\n      // To make sure the color is set in the CSS file\n      return `active${value}`;\n    } else {\n      console.error(\"Error in the value of the cell\");\n    }\n  }\n\n  render() {\n    const { indR, indC } = this.props.position; // Coordinates of the bloc. Info to send to the parent\n    const size = this.props.size; // Dimension of the bloc to display\n\n    const styles = {\n      height: `${size}px`,\n      width: `${size}px`\n    }; // Size of the bloc\n\n    return (\n      <div\n        // When events are detected, call the parent function\n        onClick={() => this.props.handleClic(indR, indC)} // Event for click -> set the change\n        onMouseEnter={() => this.props.handleEnter(indR, indC)} // If the mouse is inside a bloc\n        className={\"bloc \" + this.createClass()} // Class of bloc + active or not\n        style={styles}\n      >\n        {/* {this.props.value} */}\n      </div>\n    );\n  }\n}\n","/* Functions use to handle the Map */\nexport const getKeyFromCoordinates = (r, c) => {\n  // Return the value of the key for a cell at coordinates (c,r)\n  return `R${r}C${c}`;\n};\n\nexport const getCoordinatesFromKey = key => {\n  // Return the value of the coordinates (c,r) from a key\n  // Return is an object\n  // The key is a string\n\n  let i = 1; // The first value is 'R'\n  let indR = \"\";\n  let indC = \"\";\n\n  while (key[i] !== \"C\") {\n    indR = indR + key[i];\n    i++;\n  }\n\n  i += 1; // Skip 'C\"\n\n  for (; i < key.length; i++) {\n    indC = indC + key[i];\n  }\n\n  //Conver the strig value into integer\n  indR = parseInt(indR, 10);\n  indC = parseInt(indC, 10);\n\n  return { indR: indR, indC: indC };\n};\n\nexport const getValueCell = (indR, indC, map) => {\n  // Return the value that correspond to the coordinates\n  const value = map.get(getKeyFromCoordinates(indR, indC));\n\n  if (value === undefined) {\n    // The value is not set so the cell is dead\n    return 0;\n  }\n  return value;\n};\n","import React from \"react\";\nimport Bloc from \"./Bloc\";\n\nimport { getValueCell } from \"../constantes/utilities\";\n\nexport default class Windows extends React.Component {\n  handleEnterNewBloc = (indR, indC) => {\n    // Function call by the children\n    // (indC, indR) are the coordinates of the cell\n    // indR -> value of the row\n    // indC -> value of the column\n    // If the user is clicking, change the value of the calling bloc on enter\n    const click = this.props.specific.get().click;\n\n    if (click) {\n      this.props.changeValueCell(indR, indC);\n    }\n  };\n\n  handleUserClicInsideBloc = (indR, indC) => {\n    // Function call by the children\n    // (indC, indR) are the coordinates of the cell\n    // indR -> value of the row\n    // indC -> value of the column\n    // Handle is the user is clicking inside a bloc\n\n    let nextState = this.props.specific.get();\n\n    nextState.click = !nextState.click;\n    if (nextState.click) {\n      // We need to change the current value of the bloc\n      this.props.changeValueCell(indR, indC, nextState);\n    }\n  };\n\n  displayBlocs() {\n    // return the board to display\n    const { size, nbR, nbC } = this.props.core.get();\n    const { cells } = this.props.specific.get();\n\n    let arrayBlocs = []; // Array of blocs\n    let tmpRow = [];\n    let value; // value of the cell\n\n    for (let r = 0; r < nbR; r++) {\n      tmpRow = [];\n\n      for (let c = 0; c < nbC; c++) {\n        // Iterate over the columns\n\n        value = getValueCell(r, c, cells); // value of the cell\n\n        tmpRow.push(\n          <Bloc\n            key={`R${r}C${c}`}\n            position={{ indR: r, indC: c }}\n            value={value}\n            handleClic={this.handleUserClicInsideBloc}\n            handleEnter={this.handleEnterNewBloc}\n            size={size}\n          />\n        );\n      }\n\n      arrayBlocs.push(\n        <div\n          className=\"d-flex justify-content-center align-items-center\"\n          key={`R${r}`}\n        >\n          {tmpRow}\n        </div>\n      );\n    }\n\n    return arrayBlocs;\n  }\n\n  render() {\n    return <div>{this.displayBlocs()}</div>;\n  }\n}\n","import {\n  getKeyFromCoordinates,\n  getCoordinatesFromKey,\n  getValueCell\n} from \"../../constantes/utilities\";\n\nexport class Automaton {\n  constructor(map, nbStates, nbR, nbC) {\n    // Map contains the board\n    // nbStates number of state of the automaton\n    // nbR, nbC size of the board\n    // two functions to handle key in the map\n\n    this.map = map; // Matrix is use as reference\n    this.nbStates = nbStates; // Nb of states in the simulation\n\n    this.nbR = nbR; // Number of rows\n    this.nbC = nbC; // Number of columns\n  }\n\n  getValueCell(indR, indC) {\n    // Return the value of the cell at coordinates (indC, indR)\n\n    return getValueCell(indR, indC, this.map);\n  }\n\n  randomBoard() {\n    // Init a board with random state for the cell\n    // Return the map of the new values\n    let nMap = new Map();\n\n    let key = null; // Key in the map\n    let value = null; // value in the map\n\n    for (let r = 0; r < this.nbR; r++) {\n      // Iterate over the board\n      for (let c = 0; c < this.nbC; c++) {\n        key = getKeyFromCoordinates(r, c);\n        value = Math.floor(Math.random() * Math.floor(this.nbStates));\n\n        if (value !== 0) {\n          // We only store alive cells\n          nMap.set(key, value);\n        }\n      }\n    }\n\n    this.map = nMap; // update the new map reference\n\n    return nMap;\n  }\n\n  next() {\n    // Compute the next state of the simulation\n    let nMap = new Map();\n\n    let cValue; // value of the next state of the cell\n    let cKey; // key to store in the map\n\n    this.map.forEach((value, key) => {\n      // Iterate over all alive cells\n      const { indR, indC } = getCoordinatesFromKey(key);\n\n      // Iterate over the neighboors\n      for (let r = indR - 1; r <= indR + 1; r++) {\n        for (let c = indC - 1; c <= indC + 1; c++) {\n          cValue = this.rules(r, c);\n          if (cValue !== 0) {\n            // Only store alive cell\n            cKey = getKeyFromCoordinates(r, c);\n\n            nMap.delete(cKey); // in case the cell was already visited\n            nMap.set(cKey, cValue);\n          }\n        }\n      }\n    });\n\n    this.map = nMap; // update the new map reference\n\n    return nMap;\n  }\n\n  checkCells() {\n    // Iterate over the value of the cells\n    // Return a boolean\n    // true => the board is correct according to the automaton\n    // false => incorrect\n\n    let values = this.map.values(); // Map iterator that contain value\n\n    for (let s = 0; s < this.map.size; s++) {\n      // Iterate over the value of the cells\n      if (!this.checkValue(values.next().value)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  checkValue(value) {\n    // Check if the value can be used in the automaton\n    // Return a boolean\n\n    return 0 <= value && value < this.nbStates;\n  }\n\n  rules(indR, indC) {\n    // (indC, indR) are the coordinates of the cell\n    // indR -> value of the row\n    // indC -> value of the column\n    // Define all the rules of the simulation\n    // Kind of abstract method\n    // Define in the children\n    // Return the next state of the cell\n  }\n\n  changeValue(indR, indC) {\n    // (indC, indR) are the coordinates of the cell\n    // indR -> value of the row\n    // indC -> value of the column\n    // Return the next value of the cell\n    // Circular change\n\n    return (this.getValueCell(indR, indC) + 1) % this.nbStates;\n  }\n\n  countNeighbours(indR, indC, vToCheck) {\n    // (indC, indR) are the coordinates of the cell\n    // vToCheck is the state of the neighbour to check\n\n    // Values to iterate (ie Neighboors)\n\n    let compt = 0;\n    let cVal; // We can just look at the map. Because 0 aren't store\n\n    // Iterate over the neighboors\n    for (let r = indR - 1; r <= indR + 1; r++) {\n      for (let c = indC - 1; c <= indC + 1; c++) {\n        if (r !== indR || c !== indC) {\n          // We don't count the cell itself\n          cVal = this.getValueCell(r, c);\n          if (cVal === vToCheck) {\n            // Count the state of the cell\n            compt += 1;\n          }\n        }\n      }\n    }\n\n    return compt;\n  }\n}\n","import { Automaton } from \"./Automaton\";\nimport { CONWAY, DAY_NIGHT, HIGHLIFE } from \"../../constantes/constantes\";\n\nexport class GameOfLife extends Automaton {\n  constructor(map, nbR, nbC, variant) {\n    super(map, 2, nbR, nbC); // The game of life has always 2 states\n\n    this.fNext = undefined; // Function to call each next\n    // Depend on the variant choosen\n\n    switch (variant) {\n      // Select the right rules based on the variant\n      case CONWAY:\n        this.fNext = this.rulesConway;\n        break;\n      case DAY_NIGHT:\n        this.fNext = this.rulesDayNight;\n        break;\n      case HIGHLIFE:\n        this.fNext = this.rulesHighLife;\n        break;\n      default:\n        console.error(\"Error in the variant selection\");\n        break;\n    }\n  }\n\n  rules(indR, indC) {\n    // (indC, indR) are the coordinates of the cell\n    // indR -> value of the row\n    // indC -> value of the column\n    // Return the next state of the cell based on the simulation variant\n    const cellValue = this.getValueCell(indR, indC);\n    const neighbour = this.countNeighbours(indR, indC, 1); // Count the cells alive\n\n    const nextCell = this.fNext(cellValue, neighbour); // NextState of the cell\n\n    return nextCell;\n  }\n\n  rulesConway(cState, neighbour) {\n    // Compute the nextState of the cell based on the rules of the game of life by Conway\n    // cState -> current state of the cell\n    // neighboor -> number of cell alive around the cell\n    if (neighbour === 3) {\n      // 3 neighbours, the cell live\n      // If already living, stay in this state\n      return 1;\n    } else if (neighbour === 2) {\n      // stay in is current status\n      return cState;\n    } else {\n      // die\n      return 0;\n    }\n  }\n\n  rulesDayNight(cState, neighbour) {\n    // Compute the nextState of the cell based on the variant day & night of the game of life\n    // cState -> current state of the cell\n    // neighboor -> number of cell alive around the cell\n\n    const nbDeadN = 8 - neighbour; // Number of dead neighbour based on the number of alive neighboor\n\n    if (cState === 0) {\n      // The current cell is dead\n      if (nbDeadN === 3 || nbDeadN === 6 || nbDeadN === 7 || nbDeadN === 8) {\n        return 1;\n      }\n      return 0;\n    } else {\n      // the cell is alive\n      if (\n        neighbour === 3 ||\n        neighbour === 4 ||\n        neighbour === 6 ||\n        neighbour === 7 ||\n        neighbour === 8\n      ) {\n        return 1;\n      }\n      return 0;\n    }\n  }\n\n  rulesHighLife(cState, neighbour) {\n    // Compute the nextState of the cell based on the variant HighLife of the game of life\n    // cState -> current state of the cell\n    // neighboor -> number of cell alive around the cell\n\n    if (cState === 0) {\n      // The current cell is dead\n      if (neighbour === 3 || neighbour === 6) {\n        return 1;\n      }\n    } else {\n      // the cell is alive\n      if (neighbour === 2 || neighbour === 3) {\n        return 1;\n      }\n    }\n\n    return 0;\n  }\n}\n","import { Automaton } from \"./Automaton\";\n\nexport class ColoredVariant extends Automaton {\n  constructor(map, nbR, nbC, nbStates) {\n    super(map, nbStates, nbR, nbC);\n  }\n\n  rules(indR, indC) {\n    // (indC, indR) are the coordinates of the cell\n    // indR -> value of the row\n    // indC -> value of the column\n    // Return the next state of the cell\n    const currentState = this.getValueCell(indR, indC);\n    const nextState = this.changeValue(indR, indC);\n\n    const neighbour = this.countNeighbours(indR, indC, nextState); // Count the cells alive\n\n    if (neighbour >= 3) {\n      // 3 neighbours, the cell evolve\n      return nextState;\n    } else {\n      // Stay in current state\n      return currentState;\n    }\n  }\n}\n","import React from \"react\";\n\n/* React Component */\n\nimport Controls from \"./Controls\";\nimport Windows from \"../Display/Windows\";\n\n/* Automaton */\n\nimport { GameOfLife } from \"./Algo/GameOfLife\";\nimport { ColoredVariant } from \"./Algo/ColoredVariant\";\n\n/* Constantes */\n\nimport {\n  /* Use for the state */\n  INIT_CONTROLS,\n  INIT_CORE,\n  INIT_WINDOWS,\n  /* Use for the init of the automaton */\n  GAME_OF_LIFE,\n  COLORED_VARIANT\n} from \"../constantes/constantes\";\nimport { getKeyFromCoordinates } from \"../constantes/utilities\";\n\nexport default class CellularGame extends React.Component {\n  // CellularGame contains the state of the controls and Windows sections\n  constructor(props) {\n    super(props);\n\n    this.automaton = null; // Contains the logic of the simulation\n    this.animation = null; // Use to animate the simulation\n\n    this.state = {\n      controls: {\n        // State of the controls part\n        ...INIT_CONTROLS\n      },\n      windows: {\n        // State of the windows part\n        ...INIT_WINDOWS\n      },\n      core: {\n        // Shared state\n        ...INIT_CORE\n      }\n    };\n  }\n\n  /* Life cycle component */\n\n  componentDidMount() {\n    // When the component mount,\n    this.initAutomaton(); // Init the automaton for the first time\n  }\n\n  /* Animation part */\n\n  stopAnimation = () => {\n    // Stop the animation of the simulation\n    if (this.animation !== null) {\n      // the animation is set\n      clearInterval(this.animation);\n      this.animation = null;\n    }\n  };\n\n  startAnimation = () => {\n    // Start the animation of the simulation\n    this.animation = setInterval(this.stepAutomaton, this.state.controls.speed);\n  };\n\n  changeValueAnimation = () => {\n    // Use when the user change the value of animation will the animation is playing\n    if (this.animation !== null) {\n      // The animation is currently play\n      this.stopAnimation();\n      this.startAnimation();\n    }\n  };\n\n  handlePlayPause = () => {\n    // Call by controls when the user hit the play/pause button\n    if (this.animation === null) {\n      // Create a new animation at a specific speed\n      this.startAnimation();\n    } else {\n      // The user wants to stop the animation\n      this.stopAnimation();\n    }\n\n    let controls = this.getStateControls();\n    controls.play = !controls.play;\n    this.setStateControls(controls);\n  };\n\n  /* Automaton part */\n\n  initAutomaton = () => {\n    // Init the automaton\n    // Init once even if the matrix change\n    // The matrix use by the Automaton is a reference to the cells in the state\n    switch (this.state.controls.type) {\n      case GAME_OF_LIFE:\n        this.automaton = new GameOfLife(\n          this.state.windows.cells,\n          this.state.core.nbR,\n          this.state.core.nbC,\n          this.state.controls.options.variant\n        );\n        break;\n      case COLORED_VARIANT:\n        this.automaton = new ColoredVariant(\n          this.state.windows.cells,\n          this.state.core.nbR,\n          this.state.core.nbC,\n          this.state.controls.options.nbStates\n        );\n        break;\n      default:\n        console.error(\"Error in the Automaton selection\");\n        break;\n    }\n\n    // Check if the current board can be use for the current automaton\n    if (!this.automaton.checkCells()) {\n      this.clearCells();\n    }\n  };\n\n  stepAutomaton = () => {\n    // Compute the next state\n\n    let nextStateWindows = this.getStateWindows();\n    nextStateWindows.cells = this.automaton.next(); // Compute the next state of the cells\n\n    this.setStateWindows(nextStateWindows);\n  };\n\n  /* Functions to use the board has Map */\n\n  getNewValue = (indR, indC) => {\n    // Get the new value of the cell on click (or enter)\n    // indR -> value of the row\n    // indC -> value of the column\n    // (indC, indR) are the coordinates of the cell\n    return this.automaton.changeValue(indR, indC);\n  };\n\n  changeValueCell = (indR, indC, stateWindows = null) => {\n    // Change the value of the cell and set the new state\n    // (indC, indR) are the coordinates of the cell\n    // indR -> value of the row\n    // indC -> value of the column\n    let newState = stateWindows;\n    if (newState === null) {\n      // If there is a modification is the state, avoid multiple set\n      newState = this.getStateWindows();\n    }\n\n    const value = this.getNewValue(indR, indC); // Change the value of the cell\n    const key = getKeyFromCoordinates(indR, indC);\n\n    newState.cells.delete(key); // remove the previous value (if it is store)\n    newState.cells.set(key, value); // store the new value\n\n    this.setStateWindows(newState);\n  };\n\n  /* Functions to set up the board */\n\n  clearCells = () => {\n    // Set the matrix with 0\n    let newState = this.state;\n\n    newState.windows.cells = this.emptyCells();\n    this.initAutomaton(); // Clear the previous automaton because dimensions have changed\n\n    this.setState(newState);\n  };\n\n  emptyCells = () => {\n    // Init all the cells at 0 in the board\n    return new Map();\n  };\n\n  randomCells = () => {\n    this.initAutomaton();\n\n    let nextState = this.getStateWindows();\n    nextState.cells = this.automaton.randomBoard();\n\n    this.setStateWindows(nextState);\n  };\n\n  /* Setter of the state */\n\n  setStateCore = newCore => {\n    // Set the state of the core part\n    let nextState = this.state;\n    let callBack = undefined;\n\n    if (\n      nextState.core.nbC !== newCore.nbC ||\n      nextState.core.nbR !== newCore.nbR\n    ) {\n      // The size of the board changed\n      callBack = this.initAutomaton; // Clear the previous automaton because dimensions are differents\n    }\n\n    nextState.core = newCore;\n\n    this.setState(nextState, callBack);\n  };\n\n  setStateWindows = newWindows => {\n    // Set the state of the windows part\n    let nextState = this.state;\n    nextState.windows = newWindows;\n    this.setState(nextState);\n  };\n\n  setStateControls = newControls => {\n    // Set the state of the controls part\n\n    let nextState = this.state;\n    let callBack = undefined; // Only one call back is possible according to the control construction\n\n    if (nextState.controls.speed !== newControls.speed) {\n      // the value of the animation changed\n      callBack = this.changeValueAnimation;\n    }\n\n    if (\n      nextState.controls.type !== newControls.type ||\n      // the value of the automaton changed\n      nextState.controls.options !== newControls.options\n      // The user change options of the automaton\n    ) {\n      callBack = this.initAutomaton;\n    }\n\n    nextState.controls = newControls;\n\n    this.setState(nextState, callBack); // set the state and callback on specific changed\n  };\n\n  /* Getter of the state */\n\n  getCoreState = () => {\n    // Get the state of the core part\n    return this.state.core;\n  };\n\n  getStateWindows = () => {\n    // Get the state of the windows part\n    return this.state.windows;\n  };\n\n  getStateControls = () => {\n    // Get the state of the controls part\n    return this.state.controls;\n  };\n\n  render() {\n    return (\n      <div>\n        <h1>Automate Cellulaire</h1>\n\n        <div>\n          <h2>Nombre de cellules: {this.state.windows.cells.size}</h2>\n        </div>\n\n        <Windows\n          specific={{\n            get: this.getStateWindows,\n            set: this.setStateWindows\n          }}\n          core={{\n            get: this.getCoreState,\n            set: this.setStateCore\n          }}\n          changeValueCell={this.changeValueCell}\n        />\n\n        <Controls\n          specific={{\n            get: this.getStateControls,\n            set: this.setStateControls\n          }}\n          core={{\n            get: this.getCoreState,\n            set: this.setStateCore\n          }}\n          play={this.handlePlayPause}\n          step={this.stepAutomaton}\n          clear={this.clearCells}\n          randomCells={this.randomCells}\n        />\n      </div>\n    );\n  }\n}\n","import React from \"react\";\nimport CellularGame from \"./Logic/CellularGame\";\n\nfunction App() {\n  return (\n    <main className=\"container\">\n      <CellularGame />\n    </main>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}