{"version":3,"sources":["constantes/constantes.js","Logic/Controls.js","Display/Bloc.js","Display/Windows.js","Logic/Algo/Automaton.js","Logic/Algo/GameOfLife.js","Logic/Algo/ColoredVariant.js","Logic/CellularGame.js","App.js","serviceWorker.js","index.js"],"names":["GAME_OF_LIFE","COLORED_VARIANT","TYPE_SIMULATION","CONWAY","TYPE_GAME_OF_LIFE","INIT_CONTROLS","speed","type","options","variant","nbStates","play","INIT_WINDOWS","click","cells","Map","INIT_CORE","nbR","nbC","size","BUTTON_COLOR","MARGIN_BUTTONS","Controls","updateValueSpecific","event","stateTarget","nextState","props","specific","get","value","target","set","updateValuesCore","core","updateValuesOptionsAutomaton","nextOptions","playPauseButton","message","className","onClick","array","map","el","key","this","displayOptionsConway","displayOptionsImmigration","id","onChange","displayOptionsFromList","min","max","step","onSubmit","e","preventDefault","clear","randomCells","displayAutomatonOptions","React","Component","Bloc","console","error","position","indR","indC","styles","height","width","handleClic","onMouseEnter","handleEnter","createClass","style","Windows","handleEnterNewBloc","changeValueCell","handleUserClicInsideBloc","arrayBlocs","tmpRow","r","c","getValueCell","push","displayBlocs","Automaton","keyFromCoordinates","coordinatesFromKey","undefined","nMap","Math","floor","random","cValue","cKey","forEach","rules","delete","values","s","checkValue","next","getValue","vToCheck","compt","GameOfLife","getKeyFromCoordinates","getCoordinatesFromKey","neighbour","countNeighbours","cellValue","nextCell","rulesConway","rulesDayNight","rulesHighLife","cState","nbDeadN","ColoredVariant","currentState","changeValue","CellularGame","stopAnimation","animation","clearInterval","startAnimation","setInterval","stepAutomaton","state","controls","changeValueAnimation","handlePlayPause","newState","setState","initAutomaton","automaton","windows","checkCells","clearCells","nextStateWindows","getStateWindows","setStateWindows","i","length","parseInt","getNewValue","stateWindows","randomBoard","handleResize","w","window","innerWidth","h","innerHeight","nState","test","resizeCells","newMatrix","oldMatrix","emptyCells","setStateCore","newCore","callBack","newWindows","setStateControls","newControls","getCoreState","getStateControls","addEventListener","removeEventListener","App","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.8f9a6ac3.chunk.js","sourcesContent":["// Constants use for the name of the automaton\nexport const GAME_OF_LIFE = \"Jeu de la Vie\";\nexport const COLORED_VARIANT = \"Variante colorée\";\n\nexport const TYPE_SIMULATION = [GAME_OF_LIFE, COLORED_VARIANT]; // All the simulation implemented\n\n// Variant of the game of life\nexport const CONWAY = \"Conway: Jeu de la Vie\";\nexport const DAY_NIGHT = \"Day & Night\";\nexport const HIGHLIFE = \"HighLife\";\n\nexport const TYPE_GAME_OF_LIFE = [CONWAY, DAY_NIGHT, HIGHLIFE];\n\nconst DEFAULT_SIMULATION = 1; // Number of the default simulation\n\nexport const INIT_CONTROLS = {\n  // Initial state of the controls section\n  speed: 500, // Speed of the animation in ms\n  type: TYPE_SIMULATION[DEFAULT_SIMULATION], // Type of the simulation (ie automaton)\n  options: {\n    // Use for game of lige\n    variant: TYPE_GAME_OF_LIFE[0],\n    // Use for Immigration\n    nbStates: 3\n  }, // Options specific to the automaton\n  play: false // true is the animation is set to play\n};\n\nexport const INIT_WINDOWS = {\n  // Initial state of the windows section\n  click: false, // To handle when the user click\n  cells: new Map() // represent the board. Map with String has key and int as value\n};\n\nexport const INIT_CORE = {\n  // Initial state of the core section (ie common to all sections)\n  nbR: 30, // Number of rows\n  nbC: 70, // Number of columns\n  size: 10 // Size of the blocs\n};\n\nexport const NB_COLORS = 8; // Number of colors set in the CSS\n\n/* Buttons */\n\nexport const BUTTON_COLOR = \"btn-success\"; // Bootstrap of the button\n","import React from \"react\";\n\nimport {\n  TYPE_SIMULATION,\n  BUTTON_COLOR,\n  NB_COLORS,\n  TYPE_GAME_OF_LIFE,\n  /* Use to display options of the automaton */\n  GAME_OF_LIFE,\n  COLORED_VARIANT\n} from \"../constantes/constantes\";\n\nconst MARGIN_BUTTONS = 1; // Value of the margin X for the buttons\n\nexport default class Controls extends React.Component {\n  displayOptionsFromList(array) {\n    // Display the differents options from a list\n    // The key of the element are the name of the element\n    return array.map(el => <option key={el}>{el}</option>);\n  }\n\n  updateValueSpecific = (event, stateTarget) => {\n    // update the state specific to controls\n    let nextState = { ...this.props.specific.get() }; // Copy of the state\n    // Used in parent to compare\n    const value = event.target.value;\n\n    nextState[stateTarget] = value;\n\n    this.props.specific.set(nextState);\n  };\n\n  updateValuesCore = (event, stateTarget) => {\n    // update the state core\n    let nextState = { ...this.props.core.get() }; // Copy of the state\n    // Used in parent to compare\n    const value = event.target.value;\n\n    nextState[stateTarget] = value;\n\n    this.props.core.set(nextState);\n  };\n\n  updateValuesOptionsAutomaton = (event, stateTarget) => {\n    // update the state specific to the options of the automaton\n    let nextState = { ...this.props.specific.get() }; // Copy of the state\n    let nextOptions = { ...nextState.options };\n\n    // Used in parent to compare\n    const value = event.target.value;\n\n    nextOptions[stateTarget] = value;\n    nextState.options = nextOptions;\n\n    this.props.specific.set(nextState);\n  };\n\n  playPauseButton = () => {\n    let message = \"Play\";\n    const { play } = this.props.specific.get();\n    if (play) {\n      message = \"Pause\";\n    }\n    return (\n      <button\n        type=\"button\"\n        className={`btn ${BUTTON_COLOR} mx-${MARGIN_BUTTONS} col`}\n        onClick={() => this.props.play()}\n      >\n        {message}\n      </button>\n    );\n  };\n\n  displayAutomatonOptions() {\n    const AUTOMATON = this.props.specific.get().type;\n    switch (AUTOMATON) {\n      case GAME_OF_LIFE:\n        return this.displayOptionsConway();\n      case COLORED_VARIANT:\n        return this.displayOptionsImmigration();\n      default:\n        break;\n    }\n  }\n\n  displayOptionsConway() {\n    // Options for the game of life\n    const { variant } = this.props.specific.get().options; // all the options of the game\n    return (\n      <div id=\"OptionsConway\">\n        <hr />\n        <h3>Jeu de la vie</h3>\n        <div className=\"form-group\">\n          <label>Variante du Jeu de la Vie</label>\n          <select\n            className=\"form-control\"\n            value={variant}\n            onChange={event =>\n              this.updateValuesOptionsAutomaton(event, \"variant\")\n            }\n          >\n            {this.displayOptionsFromList(TYPE_GAME_OF_LIFE)}\n          </select>\n        </div>\n      </div>\n    );\n  }\n\n  displayOptionsImmigration() {\n    // Options for the Immigration game\n\n    const { nbStates } = this.props.specific.get().options; // all the options of the game\n    return (\n      <div id=\"OptionsImmigration\">\n        <hr />\n        <h3>Jeu de l'Immigration</h3>\n\n        <div className=\"form-group\">\n          <label>Nombre d'états: {nbStates}</label>\n          <input\n            className=\"form-control\"\n            type=\"range\"\n            value={nbStates}\n            min=\"3\"\n            max={NB_COLORS}\n            step=\"1\"\n            onChange={event =>\n              this.updateValuesOptionsAutomaton(event, \"nbStates\")\n            }\n          />\n        </div>\n      </div>\n    );\n  }\n\n  render() {\n    const { speed, type } = this.props.specific.get();\n    const { size, nbC, nbR } = this.props.core.get();\n\n    return (\n      <form\n        onSubmit={e => e.preventDefault()} // Avoid the submit when click on button\n      >\n        <hr />\n        <h3>Gestion de l'automate</h3>\n\n        <div className=\"row no-gutters justify-content-between align-items-center\">\n          <div id=\"AutomatonSelection\" className=\"form-group col-5\">\n            <label>Type d'automate</label>\n            <select\n              className=\"form-control\"\n              value={type}\n              onChange={event => this.updateValueSpecific(event, \"type\")}\n            >\n              {this.displayOptionsFromList(TYPE_SIMULATION)}\n            </select>\n          </div>\n          <div className=\"row col-6\">\n            <button\n              type=\"button\"\n              className={`btn ${BUTTON_COLOR} mx-${MARGIN_BUTTONS} col`}\n              onClick={() => this.props.clear()}\n            >\n              Vider\n            </button>\n            <button\n              type=\"button\"\n              className={`btn ${BUTTON_COLOR} mx-${MARGIN_BUTTONS} col`}\n              onClick={() => this.props.randomCells()}\n            >\n              Aléatoire\n            </button>\n          </div>\n        </div>\n\n        {this.displayAutomatonOptions()}\n\n        <hr />\n        <h3>Gestion de l'affichage</h3>\n\n        <div className=\"row\">\n          <div className=\"form-group col-4\">\n            <label>Lignes: {nbR}</label>\n            <input\n              className=\"form-control-range\"\n              type=\"range\"\n              value={nbR}\n              min=\"1\"\n              max=\"100\"\n              step=\"1\"\n              onChange={event => this.updateValuesCore(event, \"nbR\")}\n            />\n          </div>\n          <div className=\"form-group col-4\">\n            <label>Colonnes: {nbC}</label>\n            <input\n              className=\"form-control-range\"\n              type=\"range\"\n              value={nbC}\n              min=\"1\"\n              max=\"100\"\n              step=\"1\"\n              onChange={event => this.updateValuesCore(event, \"nbC\")}\n            />\n          </div>\n          <div className=\"form-group col-4\">\n            <label>Taille: {size}</label>\n            <input\n              className=\"form-control-range\"\n              type=\"range\"\n              value={size}\n              min=\"5\"\n              max=\"50\"\n              step=\"1\"\n              onChange={event => this.updateValuesCore(event, \"size\")}\n            />\n          </div>\n        </div>\n\n        <hr />\n        <h3>Gestion de la simulation</h3>\n\n        <div className=\"row no-gutters justify-content-between align-items-center\">\n          <div id=\"SpeedSelection\" className=\"form-group col-5\">\n            <label>Vitesse {speed / 1000}s</label>\n\n            <input\n              className=\"form-control-range\"\n              type=\"range\"\n              value={speed}\n              min=\"100\"\n              max=\"1000\"\n              step=\"100\"\n              onChange={event => this.updateValueSpecific(event, \"speed\")}\n            />\n          </div>\n          <div id=\"buttonsRow\" className=\"row col-6\">\n            {this.playPauseButton()}\n            <button\n              type=\"button\"\n              className={`btn ${BUTTON_COLOR} mx-${MARGIN_BUTTONS} col`}\n              onClick={() => this.props.step()}\n            >\n              Step\n            </button>\n          </div>\n        </div>\n      </form>\n    );\n  }\n}\n","import React from \"react\";\nimport \"./Bloc.css\";\n\nimport { NB_COLORS } from \"../constantes/constantes\";\n\nexport default class Bloc extends React.Component {\n  createClass() {\n    // Change the class of the bloc\n    const value = this.props.value;\n    if (0 <= value && value < NB_COLORS) {\n      // To make sure the color is set in the CSS file\n      return `active${value}`;\n    } else {\n      console.error(\"Error in the value of the cell\");\n    }\n  }\n\n  render() {\n    const { indR, indC } = this.props.position; // Coordinates of the bloc. Info to send to the parent\n    const size = this.props.size; // Dimension of the bloc to display\n\n    const styles = {\n      height: `${size}px`,\n      width: `${size}px`\n    }; // Size of the bloc\n\n    return (\n      <div\n        // When events are detected, call the parent function\n        onClick={() => this.props.handleClic(indR, indC)} // Event for click -> set the change\n        onMouseEnter={() => this.props.handleEnter(indR, indC)} // If the mouse is inside a bloc\n        className={\"bloc \" + this.createClass()} // Class of bloc + active or not\n        style={styles}\n      >\n        {/* {this.props.value} */}\n      </div>\n    );\n  }\n}\n","import React from \"react\";\nimport Bloc from \"./Bloc\";\n\nexport default class Windows extends React.Component {\n  handleEnterNewBloc = (indR, indC) => {\n    // Function call by the children\n    // (indC, indR) are the coordinates of the cell\n    // indR -> value of the row\n    // indC -> value of the column\n    // If the user is clicking, change the value of the calling bloc on enter\n    const click = this.props.specific.get().click;\n\n    if (click) {\n      this.props.changeValueCell(indR, indC);\n    }\n  };\n\n  handleUserClicInsideBloc = (indR, indC) => {\n    // Function call by the children\n    // (indC, indR) are the coordinates of the cell\n    // indR -> value of the row\n    // indC -> value of the column\n    // Handle is the user is clicking inside a bloc\n\n    let nextState = this.props.specific.get();\n\n    nextState.click = !nextState.click;\n    if (nextState.click) {\n      // We need to change the current value of the bloc\n      this.props.changeValueCell(indR, indC, nextState);\n    }\n  };\n\n  displayBlocs() {\n    // return the board to display\n    const { size, nbR, nbC } = this.props.core.get();\n\n    let arrayBlocs = []; // Array of blocs\n    let tmpRow = [];\n    let value; // value of the cell\n\n    for (let r = 0; r < nbR; r++) {\n      tmpRow = [];\n\n      for (let c = 0; c < nbC; c++) {\n        // Iterate over the columns\n\n        value = this.props.getValueCell(r, c); // value of the cell\n\n        tmpRow.push(\n          <Bloc\n            key={`R${r}C${c}`}\n            position={{ indR: r, indC: c }}\n            value={value}\n            handleClic={this.handleUserClicInsideBloc}\n            handleEnter={this.handleEnterNewBloc}\n            size={size}\n          />\n        );\n      }\n\n      arrayBlocs.push(\n        <div\n          className=\"d-flex justify-content-center align-items-center\"\n          key={`R${r}`}\n        >\n          {tmpRow}\n        </div>\n      );\n    }\n\n    return arrayBlocs;\n  }\n\n  render() {\n    return <div>{this.displayBlocs()}</div>;\n  }\n}\n","export class Automaton {\n  constructor(map, nbStates, nbR, nbC, keyFromCoordinates, coordinatesFromKey) {\n    // Map contains the board\n    // nbStates number of state of the automaton\n    // nbR, nbC size of the board\n\n    this.map = map; // Matrix is use as reference\n    this.nbStates = nbStates; // Nb of states in the simulation\n\n    this.nbR = nbR; // Number of rows\n    this.nbC = nbC; // Number of columns\n\n    // Key and Coordinates in the map\n    this.keyFromCoordinates = keyFromCoordinates;\n    this.coordinatesFromKey = coordinatesFromKey;\n  }\n\n  getMap() {\n    // Return the current map of the state of cells\n    return this.map;\n  }\n\n  getValue(indR, indC) {\n    // Return the value that correspond to the coordinates\n    const value = this.map.get(this.keyFromCoordinates(indR, indC));\n\n    if (value === undefined) {\n      // The value is not set so the cell is dead\n      return 0;\n    }\n    return value;\n  }\n\n  randomBoard() {\n    // Init a board with random state for the cell\n    // Return the map of the new values\n    let nMap = new Map();\n\n    let key = null; // Key in the map\n    let value = null; // value in the map\n\n    for (let r = 0; r < this.nbR; r++) {\n      // Iterate over the board\n      for (let c = 0; c < this.nbC; c++) {\n        key = this.keyFromCoordinates(r, c);\n        value = Math.floor(Math.random() * Math.floor(this.nbStates));\n\n        if (value !== 0) {\n          // We only store alive cells\n          nMap.set(key, value);\n        }\n      }\n    }\n\n    this.map = nMap; // update the new map reference\n\n    return nMap;\n  }\n\n  next() {\n    // Compute the next state of the simulation\n    let nMap = new Map();\n    let cValue; // value of the next state of the cell\n    let cKey; // key to store in the map\n\n    this.map.forEach((value, key) => {\n      // Iterate over all alive cells\n      const { indR, indC } = this.coordinatesFromKey(key);\n\n      // Iterate over the neighboors\n      for (let r = indR - 1; r <= indR + 1; r++) {\n        for (let c = indC - 1; c <= indC + 1; c++) {\n          cValue = this.rules(r, c);\n          if (cValue !== 0) {\n            // Only store alive cell\n            cKey = this.keyFromCoordinates(r, c);\n\n            nMap.delete(cKey); // in case the cell was already visited\n            nMap.set(cKey, cValue);\n          }\n        }\n      }\n    });\n\n    this.map = nMap; // update the new map reference\n\n    return nMap;\n  }\n\n  checkCells() {\n    // Iterate over the value of the cells\n    // Return a boolean\n    // true => the board is correct according to the automaton\n    // false => incorrect\n\n    let values = this.map.values(); // Map iterator that contain value\n\n    for (let s = 0; s < this.map.size; s++) {\n      // Iterate over the value of the cells\n      if (!this.checkValue(values.next().value)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  checkValue(value) {\n    // Check if the value can be used in the automaton\n    // Return a boolean\n\n    return 0 <= value && value < this.nbStates;\n  }\n\n  rules(indR, indC) {\n    // (indC, indR) are the coordinates of the cell\n    // indR -> value of the row\n    // indC -> value of the column\n    // Define all the rules of the simulation\n    // Kind of abstract method\n    // Define in the children\n    // Return the next state of the cell\n  }\n\n  changeValue(indR, indC) {\n    // (indC, indR) are the coordinates of the cell\n    // indR -> value of the row\n    // indC -> value of the column\n    // Return the next value of the cell\n    // Circular change\n\n    return (this.getValue(indR, indC) + 1) % this.nbStates;\n  }\n\n  countNeighbours(indR, indC, vToCheck) {\n    // (indC, indR) are the coordinates of the cell\n    // vToCheck is the state of the neighbour to check\n\n    // Values to iterate (ie Neighboors)\n\n    let compt = 0;\n    let cVal; // We can just look at the map. Because 0 aren't store\n\n    // Iterate over the neighboors\n    for (let r = indR - 1; r <= indR + 1; r++) {\n      for (let c = indC - 1; c <= indC + 1; c++) {\n        if (r !== indR || c !== indC) {\n          // We don't count the cell itself\n          cVal = this.getValue(r, c);\n          if (cVal === vToCheck) {\n            // Count the state of the cell\n            compt += 1;\n          }\n        }\n      }\n    }\n\n    return compt;\n  }\n}\n","import { Automaton } from \"./Automaton\";\nimport { CONWAY, DAY_NIGHT, HIGHLIFE } from \"../../constantes/constantes\";\n\nexport class GameOfLife extends Automaton {\n  constructor(\n    map,\n    nbR,\n    nbC,\n    getKeyFromCoordinates,\n    getCoordinatesFromKey,\n    variant\n  ) {\n    super(map, 2, nbR, nbC, getKeyFromCoordinates, getCoordinatesFromKey); // The game of life has always 2 states\n    this.variant = variant;\n  }\n\n  rules(indR, indC) {\n    // (indC, indR) are the coordinates of the cell\n    // indR -> value of the row\n    // indC -> value of the column\n    // Return the next state of the cell based on the simulation variant\n    const neighbour = this.countNeighbours(indR, indC, 1); // Count the cells alive\n    const cellValue = this.getValue(indR, indC);\n    let nextCell = 0; // NextState of the cell\n\n    switch (this.variant) {\n      // Select the right rules based on the variant\n      case CONWAY:\n        nextCell = this.rulesConway(cellValue, neighbour);\n        break;\n      case DAY_NIGHT:\n        nextCell = this.rulesDayNight(cellValue, neighbour);\n        break;\n      case HIGHLIFE:\n        nextCell = this.rulesHighLife(cellValue, neighbour);\n        break;\n      default:\n        console.error(\"Error in the variant selection\");\n        break;\n    }\n\n    return nextCell;\n  }\n\n  rulesConway(cState, neighbour) {\n    // Compute the nextState of the cell based on the rules of the game of life by Conway\n    // cState -> current state of the cell\n    // neighboor -> number of cell alive around the cell\n    if (neighbour === 3) {\n      // 3 neighbours, the cell live\n      // If already living, stay in this state\n      return 1;\n    } else if (neighbour === 2) {\n      // stay in is current status\n      return cState;\n    } else {\n      // die\n      return 0;\n    }\n  }\n\n  rulesDayNight(cState, neighbour) {\n    // Compute the nextState of the cell based on the variant day & night of the game of life\n    // cState -> current state of the cell\n    // neighboor -> number of cell alive around the cell\n\n    const nbDeadN = 8 - neighbour; // Number of dead neighbour based on the number of alive neighboor\n\n    if (cState === 0) {\n      // The current cell is dead\n      if (nbDeadN === 3 || nbDeadN === 6 || nbDeadN === 7 || nbDeadN === 8) {\n        return 1;\n      }\n      return 0;\n    } else {\n      // the cell is alive\n      if (\n        neighbour === 3 ||\n        neighbour === 4 ||\n        neighbour === 6 ||\n        neighbour === 7 ||\n        neighbour === 8\n      ) {\n        return 1;\n      }\n      return 0;\n    }\n  }\n\n  rulesHighLife(cState, neighbour) {\n    // Compute the nextState of the cell based on the variant HighLife of the game of life\n    // cState -> current state of the cell\n    // neighboor -> number of cell alive around the cell\n\n    if (cState === 0) {\n      // The current cell is dead\n      if (neighbour === 3 || neighbour === 6) {\n        return 1;\n      }\n    } else {\n      // the cell is alive\n      if (neighbour === 2 || neighbour === 3) {\n        return 1;\n      }\n    }\n\n    return 0;\n  }\n}\n","import { Automaton } from \"./Automaton\";\n\nexport class ColoredVariant extends Automaton {\n  constructor(\n    map,\n    nbR,\n    nbC,\n    getKeyFromCoordinates,\n    getCoordinatesFromKey,\n    nbStates\n  ) {\n    super(\n      map,\n      nbStates,\n      nbR,\n      nbC,\n      getKeyFromCoordinates,\n      getCoordinatesFromKey\n    );\n  }\n\n  rules(indR, indC) {\n    // (indC, indR) are the coordinates of the cell\n    // indR -> value of the row\n    // indC -> value of the column\n    // Return the next state of the cell\n    const currentState = this.getValue(indR, indC);\n    const nextState = this.changeValue(indR, indC);\n\n    const neighbour = this.countNeighbours(indR, indC, nextState); // Count the cells alive\n\n    if (neighbour >= 3) {\n      // 3 neighbours, the cell evolve\n      return nextState;\n    } else {\n      // Stay in current state\n      return currentState;\n    }\n  }\n}\n","import React from \"react\";\n\n/* React Component */\n\nimport Controls from \"./Controls\";\nimport Windows from \"../Display/Windows\";\n\n/* Automaton */\n\nimport { GameOfLife } from \"./Algo/GameOfLife\";\nimport { ColoredVariant } from \"./Algo/ColoredVariant\";\n\n/* Constantes */\n\nimport {\n  /* Use for the state */\n  INIT_CONTROLS,\n  INIT_CORE,\n  INIT_WINDOWS,\n  /* Use for the init of the automaton */\n  GAME_OF_LIFE,\n  COLORED_VARIANT\n} from \"../constantes/constantes\";\n\nexport default class CellularGame extends React.Component {\n  // CellularGame contains the state of the controls and Windows sections\n  constructor(props) {\n    super(props);\n\n    this.automaton = null; // Contains the logic of the simulation\n    this.animation = null; // Use to animate the simulation\n\n    this.state = {\n      controls: {\n        // State of the controls part\n        ...INIT_CONTROLS\n      },\n      windows: {\n        // State of the windows part\n        ...INIT_WINDOWS\n      },\n      core: {\n        // Shared state\n        ...INIT_CORE\n      },\n      test: {\n        // Test State\n        w: 0,\n        h: 0\n      }\n    };\n  }\n\n  /* Life cycle component */\n\n  componentDidMount() {\n    // When the component mount, add event on resize\n    // Handle when the user resize its windows\n\n    this.handleResize();\n    window.addEventListener(\"resize\", this.handleResize);\n\n    this.initAutomaton(); // Init the automaton for the first time\n  }\n\n  componentWillUnmount() {\n    // Remove all events in the event manager of the component.\n    window.removeEventListener(\"resize\", this.handleResize);\n  }\n\n  /* Animation part */\n\n  stopAnimation = () => {\n    // Stop the animation of the simulation\n    if (this.animation !== null) {\n      // the animation is set\n      clearInterval(this.animation);\n      this.animation = null;\n    }\n  };\n\n  startAnimation = () => {\n    // Start the animation of the simulation\n    this.animation = setInterval(this.stepAutomaton, this.state.controls.speed);\n  };\n\n  changeValueAnimation = () => {\n    // Use when the user change the value of animation will the animation is playing\n    if (this.animation !== null) {\n      // The animation is currently play\n      this.stopAnimation();\n      this.startAnimation();\n    }\n  };\n\n  handlePlayPause = () => {\n    // Call by controls when the user hit the play/pause button\n    if (this.animation === null) {\n      // Create a new animation at a specific speed\n      this.startAnimation();\n    } else {\n      // The user wants to stop the animation\n      this.stopAnimation();\n    }\n\n    let newState = this.state;\n    newState.controls.play = !newState.controls.play;\n    this.setState(newState);\n  };\n\n  /* Automaton part */\n\n  initAutomaton = () => {\n    // Init the automaton\n    // Init once even if the matrix change\n    // The matrix use by the Automaton is a reference to the cells in the state\n    switch (this.state.controls.type) {\n      case GAME_OF_LIFE:\n        this.automaton = new GameOfLife(\n          this.state.windows.cells,\n          this.state.core.nbR,\n          this.state.core.nbC,\n          this.getKeyFromCoordinates,\n          this.getCoordinatesFromKey,\n          this.state.controls.options.variant\n        );\n        break;\n      case COLORED_VARIANT:\n        this.automaton = new ColoredVariant(\n          this.state.windows.cells,\n          this.state.core.nbR,\n          this.state.core.nbC,\n          this.getKeyFromCoordinates,\n          this.getCoordinatesFromKey,\n          this.state.controls.options.nbStates\n        );\n        break;\n      default:\n        console.error(\"Error in the Automaton selection\");\n        break;\n    }\n\n    if (!this.automaton.checkCells()) {\n      this.clearCells();\n    }\n  };\n\n  stepAutomaton = () => {\n    // Compute the next state\n    if (this.automaton === null) {\n      // If it's the first time, init the automaton\n      this.initAutomaton();\n    }\n\n    let nextStateWindows = this.getStateWindows();\n    nextStateWindows.cells = this.automaton.next(); // Compute the next state of the cells\n\n    this.setStateWindows(nextStateWindows);\n  };\n\n  getKeyFromCoordinates = (r, c) => {\n    // Return the value of the key for a cell at coordinates (c,r)\n    return `R${r}C${c}`;\n  };\n\n  getCoordinatesFromKey = key => {\n    // Return the value of the coordinates (c,r) from a key\n    // Return is an object\n    // The key is a string\n\n    let i = 1; // The first value is 'R'\n    let indR = \"\";\n    let indC = \"\";\n\n    while (key[i] !== \"C\") {\n      indR = indR + key[i];\n      i++;\n    }\n\n    i += 1; // Skip 'C\"\n\n    for (; i < key.length; i++) {\n      indC = indC + key[i];\n    }\n\n    //Conver the strig value into integer\n    indR = parseInt(indR, 10);\n    indC = parseInt(indC, 10);\n\n    return { indR: indR, indC: indC };\n  };\n\n  getValueCell = (indR, indC) => {\n    // Return the value that correspond to the coordinates\n    const value = this.state.windows.cells.get(\n      this.getKeyFromCoordinates(indR, indC)\n    );\n\n    if (value === undefined) {\n      // The value is not set so the cell is dead\n      return 0;\n    }\n    return value;\n  };\n\n  getNewValue = (indR, indC) => {\n    // Get the new value of the cell on click (or enter)\n    // indR -> value of the row\n    // indC -> value of the column\n    // (indC, indR) are the coordinates of the cell\n    return this.automaton.changeValue(indR, indC);\n  };\n\n  changeValueCell = (indR, indC, stateWindows = null) => {\n    // Change the value of the cell and set the new state\n    // (indC, indR) are the coordinates of the cell\n    // indR -> value of the row\n    // indC -> value of the column\n    let newState = stateWindows;\n    if (newState === null) {\n      // If there is a modification is the state, avoid multiple set\n      newState = this.getStateWindows();\n    }\n\n    const value = this.getNewValue(indR, indC); // Change the value of the cell\n    const key = this.getKeyFromCoordinates(indR, indC);\n\n    newState.cells.delete(key); // remove the previous value (if it is store)\n    newState.cells.set(key, value); // store the new value\n\n    this.setStateWindows(newState);\n  };\n\n  randomCells = () => {\n    this.initAutomaton();\n\n    let nextState = this.getStateWindows();\n    nextState.cells = this.automaton.randomBoard();\n\n    this.setStateWindows(nextState);\n  };\n\n  /* Handle the resize of the windows */\n\n  handleResize = () => {\n    // Handle when the user resize its windows\n    // Change the size of the blocs\n    // Change the number of blocs\n    const w = window.innerWidth;\n    const h = window.innerHeight;\n\n    let nState = this.state;\n    nState.test = {\n      w: w,\n      h: h\n    };\n    this.setState(nState);\n  };\n\n  /* Cells handling */\n\n  resizeCells = (nbR, nbC) => {\n    // Not usefull with Map\n\n    // Return the matrix resize\n    // Keep as much values as possible\n    // Resize on top left corner\n    let newMatrix = [];\n    let tmpRow = [];\n\n    const oldMatrix = this.state.windows.cells;\n\n    for (let r = 0; r < nbR; r++) {\n      tmpRow = [];\n      for (let c = 0; c < nbC; c++) {\n        if (c < oldMatrix[0].length && r < oldMatrix.length) {\n          tmpRow.push(oldMatrix[r][c]);\n        } else {\n          tmpRow.push(0);\n        }\n      }\n      newMatrix.push(tmpRow);\n    }\n    return newMatrix;\n  };\n\n  clearCells = () => {\n    // Set the matrix with 0\n    let newState = this.state;\n\n    newState.windows.cells = this.emptyCells();\n    this.initAutomaton(); // Clear the previous automaton because dimensions have changed\n\n    this.setState(newState);\n  };\n\n  emptyCells = () => {\n    // Init all the cells at 0 in the board\n    return new Map();\n  };\n\n  /* Setter of the state */\n\n  setStateCore = newCore => {\n    // Set the state of the core part\n    let nextState = this.state;\n    let callBack = undefined;\n\n    if (\n      nextState.core.nbC !== newCore.nbC ||\n      nextState.core.nbR !== newCore.nbR\n    ) {\n      // The size of the matrix changed\n      // nextState.windows.cells = this.resizeCells(newCore.nbR, newCore.nbC); // Init a new board\n      callBack = this.initAutomaton; // Clear the previous automaton because dimensions could be differents\n    }\n\n    nextState.core = newCore;\n\n    this.setState(nextState, callBack);\n  };\n\n  setStateWindows = newWindows => {\n    // Set the state of the windows part\n    let nextState = this.state;\n    nextState.windows = newWindows;\n    this.setState(nextState);\n  };\n\n  setStateControls = newControls => {\n    // Set the state of the controls part\n\n    let nextState = this.state;\n    let callBack = undefined; // Only one call back is possible according to the control construction\n\n    if (nextState.controls.speed !== newControls.speed) {\n      // the value of the animation changed\n      callBack = this.changeValueAnimation;\n    }\n\n    if (nextState.controls.type !== newControls.type) {\n      // the value of the automaton changed\n      callBack = this.initAutomaton;\n    }\n\n    if (nextState.controls.options !== newControls.options) {\n      // The user change options of the automaton\n      callBack = this.initAutomaton;\n    }\n\n    nextState.controls = newControls;\n\n    this.setState(nextState, callBack); // set the state and callback on specific changed\n    // Change the speed of the animation if the speed has change\n  };\n\n  /* Getter of the state */\n\n  getCoreState = () => {\n    // Get the state of the core part\n    return this.state.core;\n  };\n\n  getStateWindows = () => {\n    // Get the state of the windows part\n    return this.state.windows;\n  };\n\n  getStateControls = () => {\n    // Get the state of the controls part\n    return this.state.controls;\n  };\n\n  render() {\n    return (\n      <div>\n        <h1>Automate Cellulaire</h1>\n\n        <div>\n          <h2>\n            Test Resize {this.state.test.w} x {this.state.test.h}\n          </h2>\n          <h2>Nombre de cellules: {this.state.windows.cells.size}</h2>\n        </div>\n\n        <Windows\n          specific={{\n            get: this.getStateWindows,\n            set: this.setStateWindows\n          }}\n          core={{\n            get: this.getCoreState,\n            set: this.setStateCore\n          }}\n          changeValueCell={this.changeValueCell}\n          getKeyFromCoordinates={this.getKeyFromCoordinates}\n          getValueCell={this.getValueCell}\n        />\n\n        <Controls\n          specific={{\n            get: this.getStateControls,\n            set: this.setStateControls\n          }}\n          core={{\n            get: this.getCoreState,\n            set: this.setStateCore\n          }}\n          step={this.stepAutomaton}\n          clear={this.clearCells}\n          play={this.handlePlayPause}\n          randomCells={this.randomCells}\n        />\n      </div>\n    );\n  }\n}\n","import React from \"react\";\nimport CellularGame from \"./Logic/CellularGame\";\n\nfunction App() {\n  return (\n    <main className=\"container\">\n      <CellularGame />\n    </main>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}