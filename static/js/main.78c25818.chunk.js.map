{"version":3,"sources":["constantes/constantes.js","Logic/Controls.js","Display/Bloc.js","constantes/utilities.js","Display/Windows.js","Logic/Algo/Automaton.js","Logic/Algo/GameOfLife.js","Logic/Algo/ColoredVariant.js","Logic/CellularGame.js","App.js","serviceWorker.js","index.js"],"names":["GAME_OF_LIFE","COLORED_VARIANT","TYPE_SIMULATION","CUSTOM","name","rules","born","survive","TYPE_GAME_OF_LIFE","INIT_CONTROLS","speed","type","options","variant","nbStates","play","INIT_WINDOWS","click","cells","Map","INIT_CORE","nbR","nbC","size","BUTTON_COLOR","MARGIN_BUTTONS","Controls","updateValueSpecific","event","stateTarget","nextState","props","specific","get","value","target","set","updateValuesCore","core","updateValuesOptionsAutomaton","nextOptions","updateValuesOptionsRules","position","playPauseButton","message","className","onClick","array","map","el","key","this","i","length","displayOptionsConway","displayOptionsColoredVariant","arrayValues","id","arrayCheckBoxes","push","checked","readOnly","onChange","updateVariantAutomaton","displayOptionsFromList","displayCheckBox","min","max","step","onSubmit","e","preventDefault","clear","randomCells","displayAutomatonOptions","React","Component","Bloc","console","error","indR","indC","styles","height","width","handleClic","onMouseEnter","handleEnter","createClass","style","getKeyFromCoordinates","r","c","getValueCell","undefined","Windows","handleEnterNewBloc","changeValueCell","handleUserClicInsideBloc","arrayBlocs","tmpRow","displayBlocs","Automaton","nMap","Math","floor","random","cValue","cKey","forEach","parseInt","getCoordinatesFromKey","delete","values","s","checkValue","next","vToCheck","compt","GameOfLife","cellValue","neighbour","countNeighbours","ruleForCell","cState","ColoredVariant","currentState","changeValue","CellularGame","stopAnimation","animation","clearInterval","startAnimation","setInterval","stepAutomaton","state","controls","changeValueAnimation","handlePlayPause","getStateControls","setStateControls","initAutomaton","automaton","windows","checkCells","clearCells","nextStateWindows","getStateWindows","setStateWindows","getNewValue","stateWindows","newState","emptyCells","setState","randomBoard","setStateCore","newCore","callBack","newWindows","newControls","getCoreState","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.78c25818.chunk.js","sourcesContent":["// Constants use for the name of the automaton\nexport const GAME_OF_LIFE = \"Jeu de la Vie\";\nexport const COLORED_VARIANT = \"Variante colorée\";\n\nexport const TYPE_SIMULATION = [GAME_OF_LIFE, COLORED_VARIANT]; // All the simulation implemented\n\n// Variant of the game of life\nexport const CUSTOM = {\n  name: \"Personnalisée\",\n  rules: {\n    born: [false, false, false, false, false, false, false, false, false],\n    survive: [false, false, false, false, false, false, false, false, false]\n  }\n};\nconst CONWAY = {\n  name: \"Conway: Jeu de la Vie\",\n  rules: {\n    born: [false, false, false, true, false, false, false, false, false],\n    survive: [false, false, true, true, false, false, false, false, false]\n  }\n};\nconst DAY_NIGHT = {\n  name: \"Day & Night\",\n  rules: {\n    born: [false, false, false, true, false, false, true, true, true],\n    survive: [false, false, false, true, true, false, true, true, true]\n  }\n};\nconst HIGHLIFE = {\n  name: \"HighLife\",\n  rules: {\n    born: [false, false, false, true, false, false, true, false, false],\n    survive: [false, false, true, true, false, false, false, false, false]\n  }\n};\n\nexport const TYPE_GAME_OF_LIFE = [CUSTOM, CONWAY, DAY_NIGHT, HIGHLIFE];\n\nconst DEFAULT_SIMULATION = 0; // Number of the default simulation\nconst DEFAULT_VARIANT = 1; // Number of the default variant for the game of life\n\nexport const INIT_CONTROLS = {\n  // Initial state of the controls section\n  speed: 500, // Speed of the animation in ms\n  type: TYPE_SIMULATION[DEFAULT_SIMULATION], // Type of the simulation (ie automaton)\n  options: {\n    // Use for game of life\n    variant: { ...TYPE_GAME_OF_LIFE[DEFAULT_VARIANT] },\n    // Use for Colored Life\n    nbStates: 3\n  }, // Options specific to the automaton\n  play: false // true is the animation is set to play\n};\n\nexport const INIT_WINDOWS = {\n  // Initial state of the windows section\n  click: false, // To handle when the user click\n  cells: new Map() // represent the board. Map with String has key and int as value\n};\n\nexport const INIT_CORE = {\n  // Initial state of the core section (ie common to all sections)\n  nbR: 20, // Number of rows\n  nbC: 20, // Number of columns\n  size: 15 // Size of the blocs\n};\n\nexport const NB_COLORS = 8; // Number of colors set in the CSS\n\n/* Buttons */\n\nexport const BUTTON_COLOR = \"btn-success\"; // Bootstrap of the button\n","import React from \"react\";\n\nimport {\n  TYPE_SIMULATION,\n  BUTTON_COLOR,\n  NB_COLORS,\n  TYPE_GAME_OF_LIFE,\n  CUSTOM,\n  /* Use to display options of the automaton */\n  GAME_OF_LIFE,\n  COLORED_VARIANT\n} from \"../constantes/constantes\";\n\nconst MARGIN_BUTTONS = 1; // Value of the margin X for the buttons\n\nexport default class Controls extends React.Component {\n  displayOptionsFromList(array) {\n    // Display the differents options from a list\n    // The key of the element are the name of the element\n    return array.map(el => {\n      if (typeof el === \"string\") {\n        return <option key={el}>{el}</option>;\n      }\n      return <option key={el.name}>{el.name}</option>;\n    });\n  }\n\n  updateValueSpecific = (event, stateTarget) => {\n    // update the state specific to controls\n    let nextState = { ...this.props.specific.get() }; // Copy of the state\n    // Used in parent to compare\n    const value = event.target.value;\n\n    nextState[stateTarget] = value;\n\n    this.props.specific.set(nextState);\n  };\n\n  updateValuesCore = (event, stateTarget) => {\n    // update the state core\n    let nextState = { ...this.props.core.get() }; // Copy of the state\n    // Used in parent to compare\n    const value = event.target.value;\n\n    nextState[stateTarget] = value;\n\n    this.props.core.set(nextState);\n  };\n\n  updateValuesOptionsAutomaton = (event, stateTarget) => {\n    // update the state specific to the options of the automaton\n    let nextState = { ...this.props.specific.get() }; // Copy of the state\n    let nextOptions = { ...nextState.options };\n\n    // Used in parent to compare\n    const value = event.target.value;\n\n    nextOptions[stateTarget] = value;\n    nextState.options = nextOptions;\n\n    this.props.specific.set(nextState);\n  };\n\n  updateValuesOptionsRules = (stateTarget, position) => {\n    // update the rule for game of life custom\n    let nextState = { ...this.props.specific.get() }; // Copy of the state\n    // Copy to avoid to mute the state\n    // Used in parent to compare\n    nextState.options = {\n      ...nextState.options,\n      variant: {\n        name: CUSTOM.name,\n        rules: {\n          born: [...nextState.options.variant.rules.born],\n          survive: [...nextState.options.variant.rules.survive]\n        }\n      }\n    };\n\n    nextState.options.variant.rules[stateTarget][position] = !nextState.options\n      .variant.rules[stateTarget][position];\n\n    this.props.specific.set(nextState);\n  };\n\n  updateVariantAutomaton(event) {\n    // update the variant of the automaton\n    let nextState = { ...this.props.specific.get() }; // Copy of the state\n\n    const value = event.target.value;\n\n    for (let i = 0; i < TYPE_GAME_OF_LIFE.length; i++) {\n      if (TYPE_GAME_OF_LIFE[i].name === value) {\n        // Copy to avoid to mute the state\n        // Used in parent to compare\n        nextState.options = {\n          ...nextState.options,\n          variant: {\n            name: TYPE_GAME_OF_LIFE[i].name,\n            rules: {\n              born: [...TYPE_GAME_OF_LIFE[i].rules.born],\n              survive: [...TYPE_GAME_OF_LIFE[i].rules.survive]\n            }\n          }\n        };\n      }\n    }\n\n    this.props.specific.set(nextState);\n  }\n\n  playPauseButton = () => {\n    let message = \"Play\";\n    const { play } = this.props.specific.get();\n    if (play) {\n      message = \"Pause\";\n    }\n    return (\n      <button\n        type=\"button\"\n        className={`btn ${BUTTON_COLOR} mx-${MARGIN_BUTTONS} col`}\n        onClick={() => this.props.play()}\n      >\n        {message}\n      </button>\n    );\n  };\n\n  displayAutomatonOptions() {\n    const AUTOMATON = this.props.specific.get().type;\n    switch (AUTOMATON) {\n      case GAME_OF_LIFE:\n        return this.displayOptionsConway();\n      case COLORED_VARIANT:\n        return this.displayOptionsColoredVariant();\n      default:\n        break;\n    }\n  }\n\n  displayCheckBox(arrayValues, id) {\n    let arrayCheckBoxes = [];\n\n    for (let i = 0; i <= 8; i++) {\n      arrayCheckBoxes.push(\n        <div key={`${id}${i}`} className=\"custom-control custom-switch\">\n          <input\n            type=\"checkbox\"\n            className=\"custom-control-input\"\n            checked={arrayValues[i]}\n            readOnly\n          />\n\n          <label\n            className=\"custom-control-label\"\n            onClick={() => this.updateValuesOptionsRules(id, i)}\n          >\n            {i}\n          </label>\n        </div>\n      );\n    }\n\n    return arrayCheckBoxes;\n  }\n\n  displayOptionsConway() {\n    // Options for the game of life\n    const { variant } = this.props.specific.get().options; // all the options of the game\n    return (\n      <div id=\"OptionsConway\">\n        <hr />\n        <h3>Jeu de la vie</h3>\n        <div className=\"form-group\">\n          <label>Variante du Jeu de la Vie</label>\n          <select\n            className=\"form-control\"\n            value={variant.name}\n            onChange={event => this.updateVariantAutomaton(event)}\n          >\n            {this.displayOptionsFromList(TYPE_GAME_OF_LIFE)}\n          </select>\n        </div>\n\n        <div className=\"row no-gutters\">\n          <div className=\"col-6\">\n            <h4>Cellule nait</h4>\n            {this.displayCheckBox(variant.rules.born, \"born\")}\n          </div>\n\n          <div className=\"col-6\">\n            <h4>Cellule survit</h4>\n            {this.displayCheckBox(variant.rules.survive, \"survive\")}\n          </div>\n\n          <h5>Selection du nombre de voisins vivants</h5>\n        </div>\n      </div>\n    );\n  }\n\n  displayOptionsColoredVariant() {\n    // Options for the colored variant\n\n    const { nbStates } = this.props.specific.get().options; // all the options of the game\n    return (\n      <div id=\"OptionsColoredVariant\">\n        <hr />\n        <h3>Variante à plusieurs états</h3>\n\n        <div className=\"form-group\">\n          <label>Nombre d'états: {nbStates}</label>\n          <input\n            className=\"form-control\"\n            type=\"range\"\n            value={nbStates}\n            min=\"3\"\n            max={NB_COLORS}\n            step=\"1\"\n            onChange={event =>\n              this.updateValuesOptionsAutomaton(event, \"nbStates\")\n            }\n          />\n        </div>\n      </div>\n    );\n  }\n\n  render() {\n    const { speed, type } = this.props.specific.get();\n    const { size, nbC, nbR } = this.props.core.get();\n\n    return (\n      <form\n        onSubmit={e => e.preventDefault()} // Avoid the submit when click on button\n      >\n        <hr />\n        <h3>Gestion de l'affichage</h3>\n\n        <div className=\"row\">\n          <div className=\"form-group col-4\">\n            <label>Lignes: {nbR}</label>\n            <input\n              className=\"form-control-range\"\n              type=\"range\"\n              value={nbR}\n              min=\"1\"\n              max=\"100\"\n              step=\"1\"\n              onChange={event => this.updateValuesCore(event, \"nbR\")}\n            />\n          </div>\n          <div className=\"form-group col-4\">\n            <label>Colonnes: {nbC}</label>\n            <input\n              className=\"form-control-range\"\n              type=\"range\"\n              value={nbC}\n              min=\"1\"\n              max=\"100\"\n              step=\"1\"\n              onChange={event => this.updateValuesCore(event, \"nbC\")}\n            />\n          </div>\n          <div className=\"form-group col-4\">\n            <label>Taille: {size}</label>\n            <input\n              className=\"form-control-range\"\n              type=\"range\"\n              value={size}\n              min=\"5\"\n              max=\"50\"\n              step=\"1\"\n              onChange={event => this.updateValuesCore(event, \"size\")}\n            />\n          </div>\n        </div>\n\n        <hr />\n        <h3>Gestion de la simulation</h3>\n\n        <div className=\"row no-gutters justify-content-between align-items-center\">\n          <div id=\"SpeedSelection\" className=\"form-group col-5\">\n            <label>Vitesse {speed / 1000}s</label>\n\n            <input\n              className=\"form-control-range\"\n              type=\"range\"\n              value={speed}\n              min=\"100\"\n              max=\"1000\"\n              step=\"100\"\n              onChange={event => this.updateValueSpecific(event, \"speed\")}\n            />\n          </div>\n          <div id=\"buttonsRow\" className=\"row col-6\">\n            {this.playPauseButton()}\n            <button\n              type=\"button\"\n              className={`btn ${BUTTON_COLOR} mx-${MARGIN_BUTTONS} col`}\n              onClick={() => this.props.step()}\n            >\n              Step\n            </button>\n          </div>\n        </div>\n\n        <hr />\n        <h3>Gestion de l'automate</h3>\n\n        <div className=\"row no-gutters justify-content-between align-items-center\">\n          <div id=\"AutomatonSelection\" className=\"form-group col-5\">\n            <label>Type d'automate</label>\n            <select\n              className=\"form-control\"\n              value={type}\n              onChange={event => this.updateValueSpecific(event, \"type\")}\n            >\n              {this.displayOptionsFromList(TYPE_SIMULATION)}\n            </select>\n          </div>\n          <div className=\"row col-6\">\n            <button\n              type=\"button\"\n              className={`btn ${BUTTON_COLOR} mx-${MARGIN_BUTTONS} col`}\n              onClick={() => this.props.clear()}\n            >\n              Vider\n            </button>\n            <button\n              type=\"button\"\n              className={`btn ${BUTTON_COLOR} mx-${MARGIN_BUTTONS} col`}\n              onClick={() => this.props.randomCells()}\n            >\n              Aléatoire\n            </button>\n          </div>\n        </div>\n\n        {this.displayAutomatonOptions()}\n      </form>\n    );\n  }\n}\n","import React from \"react\";\nimport \"./Bloc.css\";\n\nimport { NB_COLORS } from \"../constantes/constantes\";\n\nexport default class Bloc extends React.Component {\n  createClass() {\n    // Change the class of the bloc\n    const value = this.props.value;\n    if (0 <= value && value < NB_COLORS) {\n      // To make sure the color is set in the CSS file\n      return `active${value}`;\n    } else {\n      console.error(\"Error in the value of the cell\");\n    }\n  }\n\n  render() {\n    const { indR, indC } = this.props.position; // Coordinates of the bloc. Info to send to the parent\n    const size = this.props.size; // Dimension of the bloc to display\n\n    const styles = {\n      height: `${size}px`,\n      width: `${size}px`\n    }; // Size of the bloc\n\n    return (\n      <div\n        // When events are detected, call the parent function\n        onClick={() => this.props.handleClic(indR, indC)} // Event for click -> set the change\n        onMouseEnter={() => this.props.handleEnter(indR, indC)} // If the mouse is inside a bloc\n        className={\"bloc \" + this.createClass()} // Class of bloc + active or not\n        style={styles}\n      >\n        {/* {this.props.value} */}\n      </div>\n    );\n  }\n}\n","/* Functions use to handle the Map */\nexport const getKeyFromCoordinates = (r, c) => {\n  // Return the value of the key for a cell at coordinates (c,r)\n  return `R${r}C${c}`;\n};\n\nexport const getCoordinatesFromKey = key => {\n  // Return the value of the coordinates (c,r) from a key\n  // Return is an object\n  // The key is a string\n\n  let i = 1; // The first value is 'R'\n  let indR = \"\";\n  let indC = \"\";\n\n  while (key[i] !== \"C\") {\n    indR = indR + key[i];\n    i++;\n  }\n\n  i += 1; // Skip 'C\"\n\n  for (; i < key.length; i++) {\n    indC = indC + key[i];\n  }\n\n  //Conver the strig value into integer\n  indR = parseInt(indR, 10);\n  indC = parseInt(indC, 10);\n\n  return { indR: indR, indC: indC };\n};\n\nexport const getValueCell = (indR, indC, map) => {\n  // Return the value that correspond to the coordinates\n  const value = map.get(getKeyFromCoordinates(indR, indC));\n\n  if (value === undefined) {\n    // The value is not set so the cell is dead\n    return 0;\n  }\n  return value;\n};\n","import React from \"react\";\nimport Bloc from \"./Bloc\";\n\nimport { getValueCell } from \"../constantes/utilities\";\n\nexport default class Windows extends React.Component {\n  handleEnterNewBloc = (indR, indC) => {\n    // Function call by the children\n    // (indC, indR) are the coordinates of the cell\n    // indR -> value of the row\n    // indC -> value of the column\n    // If the user is clicking, change the value of the calling bloc on enter\n    const click = this.props.specific.get().click;\n\n    if (click) {\n      this.props.changeValueCell(indR, indC);\n    }\n  };\n\n  handleUserClicInsideBloc = (indR, indC) => {\n    // Function call by the children\n    // (indC, indR) are the coordinates of the cell\n    // indR -> value of the row\n    // indC -> value of the column\n    // Handle is the user is clicking inside a bloc\n\n    let nextState = this.props.specific.get();\n\n    nextState.click = !nextState.click;\n    if (nextState.click) {\n      // We need to change the current value of the bloc\n      this.props.changeValueCell(indR, indC, nextState);\n    }\n  };\n\n  displayBlocs() {\n    // return the board to display\n    const { size, nbR, nbC } = this.props.core.get();\n    const { cells } = this.props.specific.get();\n\n    let arrayBlocs = []; // Array of blocs\n    let tmpRow = [];\n    let value; // value of the cell\n\n    for (let r = 0; r < nbR; r++) {\n      tmpRow = [];\n\n      for (let c = 0; c < nbC; c++) {\n        // Iterate over the columns\n\n        value = getValueCell(r, c, cells); // value of the cell\n\n        tmpRow.push(\n          <Bloc\n            key={`R${r}C${c}`}\n            position={{ indR: r, indC: c }}\n            value={value}\n            handleClic={this.handleUserClicInsideBloc}\n            handleEnter={this.handleEnterNewBloc}\n            size={size}\n          />\n        );\n      }\n\n      arrayBlocs.push(\n        <div\n          className=\"d-flex justify-content-center align-items-center\"\n          key={`R${r}`}\n        >\n          {tmpRow}\n        </div>\n      );\n    }\n\n    return arrayBlocs;\n  }\n\n  render() {\n    return <div>{this.displayBlocs()}</div>;\n  }\n}\n","import {\n  getKeyFromCoordinates,\n  getCoordinatesFromKey,\n  getValueCell\n} from \"../../constantes/utilities\";\n\nexport class Automaton {\n  constructor(map, nbStates, nbR, nbC) {\n    // Map contains the board\n    // nbStates number of state of the automaton\n    // nbR, nbC size of the board\n    // two functions to handle key in the map\n\n    this.map = map; // Matrix is use as reference\n    this.nbStates = nbStates; // Nb of states in the simulation\n\n    this.nbR = nbR; // Number of rows\n    this.nbC = nbC; // Number of columns\n  }\n\n  getValueCell(indR, indC) {\n    // Return the value of the cell at coordinates (indC, indR)\n\n    return getValueCell(indR, indC, this.map);\n  }\n\n  randomBoard() {\n    // Init a board with random state for the cell\n    // Return the map of the new values\n    let nMap = new Map();\n\n    let key = null; // Key in the map\n    let value = null; // value in the map\n\n    for (let r = 0; r < this.nbR; r++) {\n      // Iterate over the board\n      for (let c = 0; c < this.nbC; c++) {\n        key = getKeyFromCoordinates(r, c);\n        value = Math.floor(Math.random() * Math.floor(this.nbStates));\n\n        if (value !== 0) {\n          // We only store alive cells\n          nMap.set(key, value);\n        }\n      }\n    }\n\n    this.map = nMap; // update the new map reference\n\n    return nMap;\n  }\n\n  next() {\n    // Compute the next state of the simulation\n    let nMap = new Map();\n\n    let cValue; // value of the next state of the cell\n    let cKey; // key to store in the map\n\n    this.map.forEach((value, key) => {\n      // Iterate over all alive cells\n      const { indR, indC } = getCoordinatesFromKey(key);\n\n      // Iterate over the neighboors\n      for (let r = indR - 1; r <= indR + 1; r++) {\n        for (let c = indC - 1; c <= indC + 1; c++) {\n          cValue = this.rules(r, c);\n          if (cValue !== 0) {\n            // Only store alive cell\n            cKey = getKeyFromCoordinates(r, c);\n\n            nMap.delete(cKey); // in case the cell was already visited\n            nMap.set(cKey, cValue);\n          }\n        }\n      }\n    });\n\n    this.map = nMap; // update the new map reference\n\n    return nMap;\n  }\n\n  checkCells() {\n    // Iterate over the value of the cells\n    // Return a boolean\n    // true => the board is correct according to the automaton\n    // false => incorrect\n\n    let values = this.map.values(); // Map iterator that contain value\n\n    for (let s = 0; s < this.map.size; s++) {\n      // Iterate over the value of the cells\n      if (!this.checkValue(values.next().value)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  checkValue(value) {\n    // Check if the value can be used in the automaton\n    // Return a boolean\n\n    return 0 <= value && value < this.nbStates;\n  }\n\n  rules(indR, indC) {\n    // (indC, indR) are the coordinates of the cell\n    // indR -> value of the row\n    // indC -> value of the column\n    // Define all the rules of the simulation\n    // Kind of abstract method\n    // Define in the children\n    // Return the next state of the cell\n  }\n\n  changeValue(indR, indC) {\n    // (indC, indR) are the coordinates of the cell\n    // indR -> value of the row\n    // indC -> value of the column\n    // Return the next value of the cell\n    // Circular change\n\n    return (this.getValueCell(indR, indC) + 1) % this.nbStates;\n  }\n\n  countNeighbours(indR, indC, vToCheck) {\n    // (indC, indR) are the coordinates of the cell\n    // vToCheck is the state of the neighbour to check\n\n    // Values to iterate (ie Neighboors)\n\n    let compt = 0;\n    let cVal; // We can just look at the map. Because 0 aren't store\n\n    // Iterate over the neighboors\n    for (let r = indR - 1; r <= indR + 1; r++) {\n      for (let c = indC - 1; c <= indC + 1; c++) {\n        if (r !== indR || c !== indC) {\n          // We don't count the cell itself\n          cVal = this.getValueCell(r, c);\n          if (cVal === vToCheck) {\n            // Count the state of the cell\n            compt += 1;\n          }\n        }\n      }\n    }\n\n    return compt;\n  }\n}\n","import { Automaton } from \"./Automaton\";\n\nexport class GameOfLife extends Automaton {\n  constructor(map, nbR, nbC, rules) {\n    super(map, 2, nbR, nbC); // The game of life has always 2 states\n\n    this.born = rules.born;\n    this.survive = rules.survive;\n  }\n\n  rules(indR, indC) {\n    // (indC, indR) are the coordinates of the cell\n    // indR -> value of the row\n    // indC -> value of the column\n    // Return the next state of the cell based on the simulation variant\n    const cellValue = this.getValueCell(indR, indC);\n    const neighbour = this.countNeighbours(indR, indC, 1); // Count the cells alive\n\n    const nextCell = this.ruleForCell(cellValue, neighbour); // NextState of the cell\n\n    return nextCell;\n  }\n\n  ruleForCell(cState, neighbour) {\n    if (cState === 0) {\n      // the cell can born\n      if (this.born[neighbour]) {\n        return 1;\n      }\n      return 0;\n    }\n    // the cell can survive\n    else {\n      if (this.survive[neighbour]) {\n        return 1;\n      }\n      return 0;\n    }\n  }\n}\n","import { Automaton } from \"./Automaton\";\n\nexport class ColoredVariant extends Automaton {\n  constructor(map, nbR, nbC, nbStates) {\n    super(map, nbStates, nbR, nbC);\n  }\n\n  rules(indR, indC) {\n    // (indC, indR) are the coordinates of the cell\n    // indR -> value of the row\n    // indC -> value of the column\n    // Return the next state of the cell\n    const currentState = this.getValueCell(indR, indC);\n    const nextState = this.changeValue(indR, indC);\n\n    const neighbour = this.countNeighbours(indR, indC, nextState); // Count the cells alive\n\n    if (neighbour >= 3) {\n      // 3 neighbours, the cell evolve\n      return nextState;\n    } else {\n      // Stay in current state\n      return currentState;\n    }\n  }\n}\n","import React from \"react\";\n\n/* React Component */\n\nimport Controls from \"./Controls\";\nimport Windows from \"../Display/Windows\";\n\n/* Automaton */\n\nimport { GameOfLife } from \"./Algo/GameOfLife\";\nimport { ColoredVariant } from \"./Algo/ColoredVariant\";\n\n/* Constantes */\n\nimport {\n  /* Use for the state */\n  INIT_CONTROLS,\n  INIT_CORE,\n  INIT_WINDOWS,\n  /* Use for the init of the automaton */\n  GAME_OF_LIFE,\n  COLORED_VARIANT\n} from \"../constantes/constantes\";\nimport { getKeyFromCoordinates } from \"../constantes/utilities\";\n\nexport default class CellularGame extends React.Component {\n  // CellularGame contains the state of the controls and Windows sections\n  constructor(props) {\n    super(props);\n\n    this.automaton = null; // Contains the logic of the simulation\n    this.animation = null; // Use to animate the simulation\n\n    this.state = {\n      controls: {\n        // State of the controls part\n        ...INIT_CONTROLS\n      },\n      windows: {\n        // State of the windows part\n        ...INIT_WINDOWS\n      },\n      core: {\n        // Shared state\n        ...INIT_CORE\n      }\n    };\n  }\n\n  /* Life cycle component */\n\n  componentDidMount() {\n    // When the component mount,\n    this.initAutomaton(); // Init the automaton for the first time\n  }\n\n  /* Animation part */\n\n  stopAnimation = () => {\n    // Stop the animation of the simulation\n    if (this.animation !== null) {\n      // the animation is set\n      clearInterval(this.animation);\n      this.animation = null;\n    }\n  };\n\n  startAnimation = () => {\n    // Start the animation of the simulation\n    this.animation = setInterval(this.stepAutomaton, this.state.controls.speed);\n  };\n\n  changeValueAnimation = () => {\n    // Use when the user change the value of animation will the animation is playing\n    if (this.animation !== null) {\n      // The animation is currently play\n      this.stopAnimation();\n      this.startAnimation();\n    }\n  };\n\n  handlePlayPause = () => {\n    // Call by controls when the user hit the play/pause button\n    if (this.animation === null) {\n      // Create a new animation at a specific speed\n      this.startAnimation();\n    } else {\n      // The user wants to stop the animation\n      this.stopAnimation();\n    }\n\n    let controls = this.getStateControls();\n    controls.play = !controls.play;\n    this.setStateControls(controls);\n  };\n\n  /* Automaton part */\n\n  initAutomaton = () => {\n    // Init the automaton\n    // Init once even if the matrix change\n    // The matrix use by the Automaton is a reference to the cells in the state\n    switch (this.state.controls.type) {\n      case GAME_OF_LIFE:\n        this.automaton = new GameOfLife(\n          this.state.windows.cells,\n          this.state.core.nbR,\n          this.state.core.nbC,\n          this.state.controls.options.variant.rules\n        );\n        break;\n      case COLORED_VARIANT:\n        this.automaton = new ColoredVariant(\n          this.state.windows.cells,\n          this.state.core.nbR,\n          this.state.core.nbC,\n          this.state.controls.options.nbStates\n        );\n        break;\n      default:\n        console.error(\"Error in the Automaton selection\");\n        break;\n    }\n\n    // Check if the current board can be use for the current automaton\n    if (!this.automaton.checkCells()) {\n      this.clearCells();\n    }\n  };\n\n  stepAutomaton = () => {\n    // Compute the next state\n\n    let nextStateWindows = this.getStateWindows();\n    nextStateWindows.cells = this.automaton.next(); // Compute the next state of the cells\n\n    this.setStateWindows(nextStateWindows);\n  };\n\n  /* Functions to use the board has Map */\n\n  getNewValue = (indR, indC) => {\n    // Get the new value of the cell on click (or enter)\n    // indR -> value of the row\n    // indC -> value of the column\n    // (indC, indR) are the coordinates of the cell\n    return this.automaton.changeValue(indR, indC);\n  };\n\n  changeValueCell = (indR, indC, stateWindows = null) => {\n    // Change the value of the cell and set the new state\n    // (indC, indR) are the coordinates of the cell\n    // indR -> value of the row\n    // indC -> value of the column\n    let newState = stateWindows;\n    if (newState === null) {\n      // If there is a modification is the state, avoid multiple set\n      newState = this.getStateWindows();\n    }\n\n    const value = this.getNewValue(indR, indC); // Change the value of the cell\n    const key = getKeyFromCoordinates(indR, indC);\n\n    newState.cells.delete(key); // remove the previous value (if it is store)\n    newState.cells.set(key, value); // store the new value\n\n    this.setStateWindows(newState);\n  };\n\n  /* Functions to set up the board */\n\n  clearCells = () => {\n    // Set the matrix with 0\n    let newState = this.state;\n\n    newState.windows.cells = this.emptyCells();\n    this.initAutomaton(); // Clear the previous automaton because dimensions have changed\n\n    this.setState(newState);\n  };\n\n  emptyCells = () => {\n    // Init all the cells at 0 in the board\n    return new Map();\n  };\n\n  randomCells = () => {\n    this.initAutomaton();\n\n    let nextState = this.getStateWindows();\n    nextState.cells = this.automaton.randomBoard();\n\n    this.setStateWindows(nextState);\n  };\n\n  /* Setter of the state */\n\n  setStateCore = newCore => {\n    // Set the state of the core part\n    let nextState = this.state;\n    let callBack = undefined;\n\n    if (\n      nextState.core.nbC !== newCore.nbC ||\n      nextState.core.nbR !== newCore.nbR\n    ) {\n      // The size of the board changed\n      callBack = this.initAutomaton; // Clear the previous automaton because dimensions are differents\n    }\n\n    nextState.core = newCore;\n\n    this.setState(nextState, callBack);\n  };\n\n  setStateWindows = newWindows => {\n    // Set the state of the windows part\n    let nextState = this.state;\n    nextState.windows = newWindows;\n    this.setState(nextState);\n  };\n\n  setStateControls = newControls => {\n    // Set the state of the controls part\n\n    let nextState = this.state;\n    let callBack = undefined; // Only one call back is possible according to the control construction\n\n    if (nextState.controls.speed !== newControls.speed) {\n      // the value of the animation changed\n      callBack = this.changeValueAnimation;\n    }\n\n    if (\n      nextState.controls.type !== newControls.type ||\n      // the value of the automaton changed\n      nextState.controls.options.variant.name !==\n        newControls.options.variant.name ||\n      // the value of the rules changed\n      nextState.controls.options.variant.rules !==\n        newControls.options.variant.rules\n\n      // The user change options of the automaton\n    ) {\n      callBack = this.initAutomaton;\n    }\n\n    nextState.controls = newControls;\n\n    this.setState(nextState, callBack); // set the state and callback on specific changed\n  };\n\n  /* Getter of the state */\n\n  getCoreState = () => {\n    // Get the state of the core part\n    return this.state.core;\n  };\n\n  getStateWindows = () => {\n    // Get the state of the windows part\n    return this.state.windows;\n  };\n\n  getStateControls = () => {\n    // Get the state of the controls part\n    return this.state.controls;\n  };\n\n  render() {\n    return (\n      <div>\n        <h1>Automate Cellulaire</h1>\n\n        <div>\n          <h2>Nombre de cellules: {this.state.windows.cells.size}</h2>\n        </div>\n\n        <Windows\n          specific={{\n            get: this.getStateWindows,\n            set: this.setStateWindows\n          }}\n          core={{\n            get: this.getCoreState,\n            set: this.setStateCore\n          }}\n          changeValueCell={this.changeValueCell}\n        />\n\n        <Controls\n          specific={{\n            get: this.getStateControls,\n            set: this.setStateControls\n          }}\n          core={{\n            get: this.getCoreState,\n            set: this.setStateCore\n          }}\n          play={this.handlePlayPause}\n          step={this.stepAutomaton}\n          clear={this.clearCells}\n          randomCells={this.randomCells}\n        />\n      </div>\n    );\n  }\n}\n","import React from \"react\";\nimport CellularGame from \"./Logic/CellularGame\";\n\nfunction App() {\n  return (\n    <main className=\"container\">\n      <CellularGame />\n    </main>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}