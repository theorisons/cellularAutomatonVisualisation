{"version":3,"sources":["constantes/constantes.js","Logic/Controls.js","Display/Bloc.js","constantes/utilities.js","Display/Windows.js","Logic/Algo/GameOfLife.js","Logic/Algo/Automaton.js","Logic/CellularGame.js","App.js","serviceWorker.js","index.js"],"names":["CUSTOM","name","rules","born","survive","TYPE_GAME_OF_LIFE","INIT_CONTROLS","speed","variant","play","INIT_WINDOWS","click","cells","Map","INIT_CORE","nbR","nbC","size","BUTTON_COLOR","MARGIN_BUTTONS","Controls","updateValueSpecific","event","stateTarget","nextState","props","specific","get","value","target","set","updateValuesCore","core","updateValuesOptionsRules","position","playPauseButton","message","type","className","onClick","array","map","el","key","this","i","length","arrayValues","id","arrayCheckBoxes","push","checked","readOnly","onSubmit","e","preventDefault","min","max","step","onChange","updateVariantAutomaton","displayOptionsFromList","clear","randomCells","displayCheckBox","React","Component","Bloc","console","error","indR","indC","styles","height","width","handleClic","onMouseEnter","handleEnter","createClass","style","getKeyFromCoordinates","r","c","getValueCell","undefined","Windows","handleEnterNewBloc","changeValueCell","handleUserClicInsideBloc","arrayBlocs","tmpRow","displayBlocs","GameOfLife","cellValue","neighbour","countNeighbours","ruleForCell","cState","nbStates","nMap","Math","floor","random","cValue","cKey","forEach","parseInt","getCoordinatesFromKey","delete","vToCheck","compt","CellularGame","stopAnimation","animation","clearInterval","startAnimation","setInterval","stepAutomaton","state","controls","changeValueAnimation","handlePlayPause","getStateControls","setStateControls","initAutomaton","automaton","windows","nextStateWindows","getStateWindows","next","setStateWindows","getNewValue","changeValue","stateWindows","newState","clearCells","emptyCells","setState","randomBoard","setStateCore","newCore","callBack","newWindows","newControls","getCoreState","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"6UACaA,EAAS,CACpBC,KAAM,mBACNC,MAAO,CACLC,KAAM,EAAC,GAAO,GAAO,GAAO,GAAO,GAAO,GAAO,GAAO,GAAO,GAC/DC,QAAS,EAAC,GAAO,GAAO,GAAO,GAAO,GAAO,GAAO,GAAO,GAAO,KAyBzDC,EAAoB,CAACL,EAtBnB,CACbC,KAAM,iCACNC,MAAO,CACLC,KAAM,EAAC,GAAO,GAAO,GAAO,GAAM,GAAO,GAAO,GAAO,GAAO,GAC9DC,QAAS,EAAC,GAAO,GAAO,GAAM,GAAM,GAAO,GAAO,GAAO,GAAO,KAGlD,CAChBH,KAAM,6BACNC,MAAO,CACLC,KAAM,EAAC,GAAO,GAAO,GAAO,GAAM,GAAO,GAAO,GAAM,GAAM,GAC5DC,QAAS,EAAC,GAAO,GAAO,GAAO,GAAM,GAAM,GAAO,GAAM,GAAM,KAGjD,CACfH,KAAM,qBACNC,MAAO,CACLC,KAAM,EAAC,GAAO,GAAO,GAAO,GAAM,GAAO,GAAO,GAAM,GAAO,GAC7DC,QAAS,EAAC,GAAO,GAAO,GAAM,GAAM,GAAO,GAAO,GAAO,GAAO,MAQvDE,EAAgB,CAE3BC,MAAO,IACPC,QAAQ,eAAMH,EALQ,IAMtBI,MAAM,GAGKC,EAAe,CAE1BC,OAAO,EACPC,MAAO,IAAIC,KAGAC,EAAY,CAEvBC,IAAK,GACLC,IAAK,GACLC,KAAM,IAOKC,EAAe,cClDtBC,EAAiB,EAEFC,E,2MAYnBC,oBAAsB,SAACC,EAAOC,GAE5B,IAAIC,EAAS,eAAQ,EAAKC,MAAMC,SAASC,OAEnCC,EAAQN,EAAMO,OAAOD,MAE3BJ,EAAUD,GAAeK,EAEzB,EAAKH,MAAMC,SAASI,IAAIN,I,EAG1BO,iBAAmB,SAACT,EAAOC,GAEzB,IAAIC,EAAS,eAAQ,EAAKC,MAAMO,KAAKL,OAE/BC,EAAQN,EAAMO,OAAOD,MAE3BJ,EAAUD,GAAeK,EAEzB,EAAKH,MAAMO,KAAKF,IAAIN,I,EAGtBS,yBAA2B,SAACV,EAAaW,GAEvC,IAAIV,EAAS,eAAQ,EAAKC,MAAMC,SAASC,OAGzCH,EAAUhB,QAAU,CAClBP,KAAMD,EAAOC,KACbC,MAAO,CACLC,KAAK,YAAKqB,EAAUhB,QAAQN,MAAMC,MAClCC,QAAQ,YAAKoB,EAAUhB,QAAQN,MAAME,WAIzCoB,EAAUhB,QAAQN,MAAMqB,GAAaW,IAAaV,EAAUhB,QAAQN,MAClEqB,GACAW,GAEF,EAAKT,MAAMC,SAASI,IAAIN,I,EA0B1BW,gBAAkB,WAChB,IAAIC,EAAU,OAKd,OAJiB,EAAKX,MAAMC,SAASC,MAA7BlB,OAEN2B,EAAU,SAGV,4BACEC,KAAK,SACLC,UAAS,cAASpB,EAAT,eAA4BC,EAA5B,QACToB,QAAS,kBAAM,EAAKd,MAAMhB,SAEzB2B,I,sFAxFgBI,GAGrB,OAAOA,EAAMC,KAAI,SAAAC,GACf,MAAkB,kBAAPA,EACF,4BAAQC,IAAKD,GAAKA,GAEpB,4BAAQC,IAAKD,EAAGzC,MAAOyC,EAAGzC,W,6CA8CdqB,GAMrB,IAJA,IAAIE,EAAS,eAAQoB,KAAKnB,MAAMC,SAASC,OAEnCC,EAAQN,EAAMO,OAAOD,MAElBiB,EAAI,EAAGA,EAAIxC,EAAkByC,OAAQD,IACxCxC,EAAkBwC,GAAG5C,OAAS2B,IAGhCJ,EAAUhB,QAAU,CAClBP,KAAMI,EAAkBwC,GAAG5C,KAC3BC,MAAO,CACLC,KAAK,YAAKE,EAAkBwC,GAAG3C,MAAMC,MACrCC,QAAQ,YAAKC,EAAkBwC,GAAG3C,MAAME,YAMhDwC,KAAKnB,MAAMC,SAASI,IAAIN,K,sCAoBVuB,EAAaC,GAG3B,IAHgC,IAAD,OAC3BC,EAAkB,GADS,WAGtBJ,GACPI,EAAgBC,KACd,yBAAKP,IAAG,UAAKK,GAAL,OAAUH,GAAKP,UAAU,gCAC/B,2BACED,KAAK,WACLC,UAAU,uBACVa,QAASJ,EAAYF,GACrBO,UAAQ,IAGV,2BACEd,UAAU,uBACVC,QAAS,kBAAM,EAAKN,yBAAyBe,EAAIH,KAEhDA,MAdAA,EAAI,EAAGA,GAAK,EAAGA,IAAM,EAArBA,GAoBT,OAAOI,I,+BAGC,IAAD,SACoBL,KAAKnB,MAAMC,SAASC,MAAvCpB,EADD,EACCA,MAAOC,EADR,EACQA,QADR,EAEoBoC,KAAKnB,MAAMO,KAAKL,MAAnCV,EAFD,EAECA,KAAMD,EAFP,EAEOA,IAAKD,EAFZ,EAEYA,IAEnB,OACE,0BACEsC,SAAU,SAAAC,GAAC,OAAIA,EAAEC,mBAEjB,6BACA,sDAEA,yBAAKjB,UAAU,OACb,yBAAKA,UAAU,oBACb,0CAAgBvB,GAChB,2BACEuB,UAAU,qBACVD,KAAK,QACLT,MAAOb,EACPyC,IAAI,IACJC,IAAI,MACJC,KAAK,IACLC,SAAU,SAAArC,GAAK,OAAI,EAAKS,iBAAiBT,EAAO,WAGpD,yBAAKgB,UAAU,oBACb,4CAAkBtB,GAClB,2BACEsB,UAAU,qBACVD,KAAK,QACLT,MAAOZ,EACPwC,IAAI,IACJC,IAAI,MACJC,KAAK,IACLC,SAAU,SAAArC,GAAK,OAAI,EAAKS,iBAAiBT,EAAO,WAGpD,yBAAKgB,UAAU,oBACb,0CAAgBrB,GAChB,2BACEqB,UAAU,qBACVD,KAAK,QACLT,MAAOX,EACPuC,IAAI,IACJC,IAAI,KACJC,KAAK,IACLC,SAAU,SAAArC,GAAK,OAAI,EAAKS,iBAAiBT,EAAO,aAKtD,6BACA,wDAEA,yBAAKgB,UAAU,6DACb,yBAAKU,GAAG,iBAAiBV,UAAU,oBACjC,0CAAgB/B,EAAQ,IAAxB,KAEA,2BACE+B,UAAU,qBACVD,KAAK,QACLT,MAAOrB,EACPiD,IAAI,MACJC,IAAI,OACJC,KAAK,MACLC,SAAU,SAAArC,GAAK,OAAI,EAAKD,oBAAoBC,EAAO,aAGvD,yBAAK0B,GAAG,aAAaV,UAAU,aAC5BM,KAAKT,kBACN,4BACEE,KAAK,SACLC,UAAS,cAASpB,EAAT,eAA4BC,EAA5B,QACToB,QAAS,kBAAM,EAAKd,MAAMiC,SAH5B,UAUJ,6BACA,qDAEA,yBAAKpB,UAAU,6DACb,yBAAKU,GAAG,qBAAqBV,UAAU,oBACrC,4DACA,4BACEA,UAAU,eACVV,MAAOpB,EAAQP,KACf0D,SAAU,SAAArC,GAAK,OAAI,EAAKsC,uBAAuBtC,KAE9CsB,KAAKiB,uBAAuBxD,KAIjC,yBAAKiC,UAAU,aACb,4BACED,KAAK,SACLC,UAAS,cAASpB,EAAT,eAA4BC,EAA5B,QACToB,QAAS,kBAAM,EAAKd,MAAMqC,UAH5B,SAOA,4BACEzB,KAAK,SACLC,UAAS,cAASpB,EAAT,eAA4BC,EAA5B,QACToB,QAAS,kBAAM,EAAKd,MAAMsC,gBAH5B,iBASF,yBAAKzB,UAAU,SACb,4CACCM,KAAKoB,gBAAgBxD,EAAQN,MAAMC,KAAM,SAG5C,yBAAKmC,UAAU,SACb,8CACCM,KAAKoB,gBAAgBxD,EAAQN,MAAME,QAAS,YAG/C,0F,GAjP4B6D,IAAMC,WCLvBC,G,4LAGjB,IAAMvC,EAAQgB,KAAKnB,MAAMG,MACzB,GAAI,GAAKA,GAASA,EF6CG,EE3CnB,MAAM,SAAN,OAAgBA,GAEhBwC,QAAQC,MAAM,oC,+BAIR,IAAD,SACgBzB,KAAKnB,MAAMS,SAA1BoC,EADD,EACCA,KAAMC,EADP,EACOA,KACRtD,EAAO2B,KAAKnB,MAAMR,KAElBuD,EAAS,CACbC,OAAO,GAAD,OAAKxD,EAAL,MACNyD,MAAM,GAAD,OAAKzD,EAAL,OAGP,OACE,yBAEEsB,QAAS,kBAAM,EAAKd,MAAMkD,WAAWL,EAAMC,IAC3CK,aAAc,kBAAM,EAAKnD,MAAMoD,YAAYP,EAAMC,IACjDjC,UAAW,QAAUM,KAAKkC,cAC1BC,MAAOP,Q,GA3BmBP,IAAMC,YCJ3Bc,EAAwB,SAACC,EAAGC,GAEvC,MAAM,IAAN,OAAWD,EAAX,YAAgBC,IA8BLC,EAAe,SAACb,EAAMC,EAAM9B,GAEvC,IAAMb,EAAQa,EAAId,IAAIqD,EAAsBV,EAAMC,IAElD,YAAca,IAAVxD,EAEK,EAEFA,GCpCYyD,E,2MACnBC,mBAAqB,SAAChB,EAAMC,GAMZ,EAAK9C,MAAMC,SAASC,MAAMhB,OAGtC,EAAKc,MAAM8D,gBAAgBjB,EAAMC,I,EAIrCiB,yBAA2B,SAAClB,EAAMC,GAOhC,IAAI/C,EAAY,EAAKC,MAAMC,SAASC,MAEpCH,EAAUb,OAASa,EAAUb,MACzBa,EAAUb,OAEZ,EAAKc,MAAM8D,gBAAgBjB,EAAMC,EAAM/C,I,8EAazC,IATa,IAOTI,EAPS,EAEcgB,KAAKnB,MAAMO,KAAKL,MAAnCV,EAFK,EAELA,KAAMF,EAFD,EAECA,IAAKC,EAFN,EAEMA,IACXJ,EAAUgC,KAAKnB,MAAMC,SAASC,MAA9Bf,MAEJ6E,EAAa,GACbC,EAAS,GAGJT,EAAI,EAAGA,EAAIlE,EAAKkE,IAAK,CAC5BS,EAAS,GAET,IAAK,IAAIR,EAAI,EAAGA,EAAIlE,EAAKkE,IAGvBtD,EAAQuD,EAAaF,EAAGC,EAAGtE,GAE3B8E,EAAOxC,KACL,kBAAC,EAAD,CACEP,IAAG,WAAMsC,EAAN,YAAWC,GACdhD,SAAU,CAAEoC,KAAMW,EAAGV,KAAMW,GAC3BtD,MAAOA,EACP+C,WAAY/B,KAAK4C,yBACjBX,YAAajC,KAAK0C,mBAClBrE,KAAMA,KAKZwE,EAAWvC,KACT,yBACEZ,UAAU,mDACVK,IAAG,WAAMsC,IAERS,IAKP,OAAOD,I,+BAIP,OAAO,6BAAM7C,KAAK+C,oB,GAzEe1B,IAAMC,WCH9B0B,EAAb,YACE,WAAYnD,EAAK1B,EAAKC,EAAKd,GAAQ,IAAD,8BAChC,4CAAMuC,EAAK,EAAG1B,EAAKC,KAEdb,KAAOD,EAAMC,KAClB,EAAKC,QAAUF,EAAME,QAJW,EADpC,mEAQQkE,EAAMC,GAKV,IAAMsB,EAAYjD,KAAKuC,aAAab,EAAMC,GACpCuB,EAAYlD,KAAKmD,gBAAgBzB,EAAMC,EAAM,GAInD,OAFiB3B,KAAKoD,YAAYH,EAAWC,KAhBjD,kCAqBcG,EAAQH,GAClB,OAAe,IAAXG,EAEErD,KAAKzC,KAAK2F,GACL,EAEF,EAIHlD,KAAKxC,QAAQ0F,GACR,EAEF,MAlCb,GCIA,WACE,WAAYrD,EAAKyD,EAAUnF,EAAKC,GAAM,oBAMpC4B,KAAKH,IAAMA,EACXG,KAAKsD,SAAWA,EAEhBtD,KAAK7B,IAAMA,EACX6B,KAAK5B,IAAMA,EAXf,yDAcesD,EAAMC,GAGjB,OAAOY,EAAab,EAAMC,EAAM3B,KAAKH,OAjBzC,oCA4BI,IALA,IAAI0D,EAAO,IAAItF,IAEX8B,EAAM,KACNf,EAAQ,KAEHqD,EAAI,EAAGA,EAAIrC,KAAK7B,IAAKkE,IAE5B,IAAK,IAAIC,EAAI,EAAGA,EAAItC,KAAK5B,IAAKkE,IAC5BvC,EAAMqC,EAAsBC,EAAGC,GAGjB,KAFdtD,EAAQwE,KAAKC,MAAMD,KAAKE,SAAWF,KAAKC,MAAMzD,KAAKsD,aAIjDC,EAAKrE,IAAIa,EAAKf,GAOpB,OAFAgB,KAAKH,IAAM0D,EAEJA,IA3CX,6BA8CU,IAIFI,EACAC,EALC,OAEDL,EAAO,IAAItF,IA0Bf,OArBA+B,KAAKH,IAAIgE,SAAQ,SAAC7E,EAAOe,GAKvB,IAL+B,MHrDA,SAAAA,GASnC,IAJA,IAAIE,EAAI,EACJyB,EAAO,GACPC,EAAO,GAEO,MAAX5B,EAAIE,IACTyB,GAAc3B,EAAIE,GAClBA,IAKF,IAFAA,GAAK,EAEEA,EAAIF,EAAIG,OAAQD,IACrB0B,GAAc5B,EAAIE,GAOpB,MAAO,CAAEyB,KAHTA,EAAOoC,SAASpC,EAAM,IAGDC,KAFrBA,EAAOmC,SAASnC,EAAM,KGiCKoC,CAAsBhE,GAArC2B,EAFuB,EAEvBA,KAAMC,EAFiB,EAEjBA,KAGLU,EAAIX,EAAO,EAAGW,GAAKX,EAAO,EAAGW,IACpC,IAAK,IAAIC,EAAIX,EAAO,EAAGW,GAAKX,EAAO,EAAGW,IAErB,KADfqB,EAAS,EAAKrG,MAAM+E,EAAGC,MAGrBsB,EAAOxB,EAAsBC,EAAGC,GAEhCiB,EAAKS,OAAOJ,GACZL,EAAKrE,IAAI0E,EAAMD,OAMvB3D,KAAKH,IAAM0D,EAEJA,IA1EX,4BA6EQ7B,EAAMC,MA7Ed,kCAuFcD,EAAMC,GAOhB,OAAQ3B,KAAKuC,aAAab,EAAMC,GAAQ,GAAK3B,KAAKsD,WA9FtD,sCAiGkB5B,EAAMC,EAAMsC,GAU1B,IAJA,IAAIC,EAAQ,EAIH7B,EAAIX,EAAO,EAAGW,GAAKX,EAAO,EAAGW,IACpC,IAAK,IAAIC,EAAIX,EAAO,EAAGW,GAAKX,EAAO,EAAGW,IAChCD,IAAMX,GAAQY,IAAMX,GAEf3B,KAAKuC,aAAaF,EAAGC,KACf2B,IAEXC,GAAS,GAMjB,OAAOA,MAxHX,MCeqBC,E,YAEnB,WAAYtF,GAAQ,IAAD,8BACjB,4CAAMA,KA8BRuF,cAAgB,WAES,OAAnB,EAAKC,YAEPC,cAAc,EAAKD,WACnB,EAAKA,UAAY,OApCF,EAwCnBE,eAAiB,WAEf,EAAKF,UAAYG,YAAY,EAAKC,cAAe,EAAKC,MAAMC,SAAShH,QA1CpD,EA6CnBiH,qBAAuB,WAEE,OAAnB,EAAKP,YAEP,EAAKD,gBACL,EAAKG,mBAlDU,EAsDnBM,gBAAkB,WAEO,OAAnB,EAAKR,UAEP,EAAKE,iBAGL,EAAKH,gBAGP,IAAIO,EAAW,EAAKG,mBACpBH,EAAS9G,MAAQ8G,EAAS9G,KAC1B,EAAKkH,iBAAiBJ,IAlEL,EAuEnBK,cAAgB,WAId,EAAKC,UAAY,IAAIjC,EACnB,EAAK0B,MAAMQ,QAAQlH,MACnB,EAAK0G,MAAMtF,KAAKjB,IAChB,EAAKuG,MAAMtF,KAAKhB,IAChB,EAAKsG,MAAMC,SAAS/G,QAAQN,QA/Eb,EAmFnBmH,cAAgB,WAGd,IAAIU,EAAmB,EAAKC,kBAC5BD,EAAiBnH,MAAQ,EAAKiH,UAAUI,OAExC,EAAKC,gBAAgBH,IAzFJ,EA8FnBI,YAAc,SAAC7D,EAAMC,GAKnB,OAAO,EAAKsD,UAAUO,YAAY9D,EAAMC,IAnGvB,EAsGnBgB,gBAAkB,SAACjB,EAAMC,GAA+B,IAAzB8D,EAAwB,uDAAT,KAKxCC,EAAWD,EACE,OAAbC,IAEFA,EAAW,EAAKN,mBAGlB,IAAMpG,EAAQ,EAAKuG,YAAY7D,EAAMC,GAC/B5B,EAAMqC,EAAsBV,EAAMC,GAExC+D,EAAS1H,MAAMgG,OAAOjE,GAER,IAAVf,GAEF0G,EAAS1H,MAAMkB,IAAIa,EAAKf,GAG1B,EAAKsG,gBAAgBI,IA3HJ,EAgInBC,WAAa,WAEX,IAAID,EAAW,EAAKhB,MAEpBgB,EAASR,QAAQlH,MAAQ,EAAK4H,aAC9B,EAAKZ,gBAEL,EAAKa,SAASH,IAvIG,EA0InBE,WAAa,WAEX,OAAO,IAAI3H,KA5IM,EA+InBkD,YAAc,WACZ,IAAIvC,EAAY,EAAKwG,kBACrBxG,EAAUZ,MAAQ,EAAKiH,UAAUa,cAEjC,EAAKR,gBAAgB1G,IAnJJ,EAwJnBmH,aAAe,SAAAC,GAEb,IAAIpH,EAAY,EAAK8F,MACjBuB,OAAWzD,EAGb5D,EAAUQ,KAAKhB,MAAQ4H,EAAQ5H,KAC/BQ,EAAUQ,KAAKjB,MAAQ6H,EAAQ7H,MAG/B8H,EAAW,EAAKjB,eAGlBpG,EAAUQ,KAAO4G,EAEjB,EAAKH,SAASjH,EAAWqH,IAvKR,EA0KnBX,gBAAkB,SAAAY,GAEhB,IAAItH,EAAY,EAAK8F,MACrB9F,EAAUsG,QAAUgB,EACpB,EAAKL,SAASjH,IA9KG,EAiLnBmG,iBAAmB,SAAAoB,GAGjB,IAAIvH,EAAY,EAAK8F,MACjBuB,OAAWzD,EAEX5D,EAAU+F,SAAShH,QAAUwI,EAAYxI,QAE3CsI,EAAW,EAAKrB,sBAIhBhG,EAAU+F,SAAS/G,QAAQP,OAAS8I,EAAYvI,QAAQP,MAExDuB,EAAU+F,SAAS/G,QAAQN,QAAU6I,EAAYvI,QAAQN,QAGzD2I,EAAW,EAAKjB,eAGlBpG,EAAU+F,SAAWwB,EAErB,EAAKN,SAASjH,EAAWqH,IAvMR,EA4MnBG,aAAe,WAEb,OAAO,EAAK1B,MAAMtF,MA9MD,EAiNnBgG,gBAAkB,WAEhB,OAAO,EAAKV,MAAMQ,SAnND,EAsNnBJ,iBAAmB,WAEjB,OAAO,EAAKJ,MAAMC,UArNlB,EAAKM,UAAY,KACjB,EAAKZ,UAAY,KAEjB,EAAKK,MAAQ,CACXC,SAAS,eAEJjH,GAELwH,QAAQ,eAEHpH,GAELsB,KAAK,eAEAlB,IAjBU,E,iFA0BjB8B,KAAKgF,kB,+BAkML,OACE,6BACE,mDAEA,6BACE,mDAAyBhF,KAAK0E,MAAMQ,QAAQlH,MAAMK,OAGpD,kBAAC,EAAD,CACES,SAAU,CACRC,IAAKiB,KAAKoF,gBACVlG,IAAKc,KAAKsF,iBAEZlG,KAAM,CACJL,IAAKiB,KAAKoG,aACVlH,IAAKc,KAAK+F,cAEZpD,gBAAiB3C,KAAK2C,kBAGxB,kBAAC,EAAD,CACE7D,SAAU,CACRC,IAAKiB,KAAK8E,iBACV5F,IAAKc,KAAK+E,kBAEZ3F,KAAM,CACJL,IAAKiB,KAAKoG,aACVlH,IAAKc,KAAK+F,cAEZlI,KAAMmC,KAAK6E,gBACX/D,KAAMd,KAAKyE,cACXvD,MAAOlB,KAAK2F,WACZxE,YAAanB,KAAKmB,mB,GA9PcE,IAAMC,WCVjC+E,MARf,WACE,OACE,0BAAM3G,UAAU,aACd,kBAAC,EAAD,QCMc4G,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,SD6H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,MAAK,SAAAC,GACjCA,EAAaC,kB","file":"static/js/main.b11a1e37.chunk.js","sourcesContent":["// Variant of the game of life\nexport const CUSTOM = {\n  name: \"Personnalisée\",\n  rules: {\n    born: [false, false, false, false, false, false, false, false, false],\n    survive: [false, false, false, false, false, false, false, false, false]\n  }\n};\nconst CONWAY = {\n  name: \"Conway: Jeu de la Vie (B2/S23)\",\n  rules: {\n    born: [false, false, false, true, false, false, false, false, false],\n    survive: [false, false, true, true, false, false, false, false, false]\n  }\n};\nconst DAY_NIGHT = {\n  name: \"Day & Night (B3678/S34678)\",\n  rules: {\n    born: [false, false, false, true, false, false, true, true, true],\n    survive: [false, false, false, true, true, false, true, true, true]\n  }\n};\nconst HIGHLIFE = {\n  name: \"HighLife (B36/S23)\",\n  rules: {\n    born: [false, false, false, true, false, false, true, false, false],\n    survive: [false, false, true, true, false, false, false, false, false]\n  }\n};\n\nexport const TYPE_GAME_OF_LIFE = [CUSTOM, CONWAY, DAY_NIGHT, HIGHLIFE];\n\nconst DEFAULT_VARIANT = 1; // Number of the default variant for the game of life\n\nexport const INIT_CONTROLS = {\n  // Initial state of the controls section\n  speed: 500, // Speed of the animation in ms\n  variant: { ...TYPE_GAME_OF_LIFE[DEFAULT_VARIANT] }, // Use for the variant of the game of life\n  play: false // true is the animation is set to play\n};\n\nexport const INIT_WINDOWS = {\n  // Initial state of the windows section\n  click: false, // To handle when the user click\n  cells: new Map() // represent the board. Map with String has key and int as value\n};\n\nexport const INIT_CORE = {\n  // Initial state of the core section (ie common to all sections)\n  nbR: 20, // Number of rows\n  nbC: 20, // Number of columns\n  size: 15 // Size of the blocs\n};\n\nexport const NB_COLORS = 2; // Number of colors set in the CSS\n\n/* Buttons */\n\nexport const BUTTON_COLOR = \"btn-success\"; // Bootstrap of the button\n","import React from \"react\";\n\nimport {\n  BUTTON_COLOR,\n  TYPE_GAME_OF_LIFE,\n  CUSTOM\n} from \"../constantes/constantes\";\n\nconst MARGIN_BUTTONS = 1; // Value of the margin X for the buttons\n\nexport default class Controls extends React.Component {\n  displayOptionsFromList(array) {\n    // Display the differents options from a list\n    // The key of the element are the name of the element\n    return array.map(el => {\n      if (typeof el === \"string\") {\n        return <option key={el}>{el}</option>;\n      }\n      return <option key={el.name}>{el.name}</option>;\n    });\n  }\n\n  updateValueSpecific = (event, stateTarget) => {\n    // update the state specific to controls\n    let nextState = { ...this.props.specific.get() }; // Copy of the state\n    // Used in parent to compare\n    const value = event.target.value;\n\n    nextState[stateTarget] = value;\n\n    this.props.specific.set(nextState);\n  };\n\n  updateValuesCore = (event, stateTarget) => {\n    // update the state core\n    let nextState = { ...this.props.core.get() }; // Copy of the state\n    // Used in parent to compare\n    const value = event.target.value;\n\n    nextState[stateTarget] = value;\n\n    this.props.core.set(nextState);\n  };\n\n  updateValuesOptionsRules = (stateTarget, position) => {\n    // update the rule for game of life custom\n    let nextState = { ...this.props.specific.get() }; // Copy of the state\n    // Copy to avoid to mute the state\n    // Used in parent to compare\n    nextState.variant = {\n      name: CUSTOM.name,\n      rules: {\n        born: [...nextState.variant.rules.born],\n        survive: [...nextState.variant.rules.survive]\n      }\n    };\n\n    nextState.variant.rules[stateTarget][position] = !nextState.variant.rules[\n      stateTarget\n    ][position];\n\n    this.props.specific.set(nextState);\n  };\n\n  updateVariantAutomaton(event) {\n    // update the variant of the automaton\n    let nextState = { ...this.props.specific.get() }; // Copy of the state\n\n    const value = event.target.value;\n\n    for (let i = 0; i < TYPE_GAME_OF_LIFE.length; i++) {\n      if (TYPE_GAME_OF_LIFE[i].name === value) {\n        // Copy to avoid to mute the state\n        // Used in parent to compare\n        nextState.variant = {\n          name: TYPE_GAME_OF_LIFE[i].name,\n          rules: {\n            born: [...TYPE_GAME_OF_LIFE[i].rules.born],\n            survive: [...TYPE_GAME_OF_LIFE[i].rules.survive]\n          }\n        };\n      }\n    }\n\n    this.props.specific.set(nextState);\n  }\n\n  playPauseButton = () => {\n    let message = \"Play\";\n    const { play } = this.props.specific.get();\n    if (play) {\n      message = \"Pause\";\n    }\n    return (\n      <button\n        type=\"button\"\n        className={`btn ${BUTTON_COLOR} mx-${MARGIN_BUTTONS} col`}\n        onClick={() => this.props.play()}\n      >\n        {message}\n      </button>\n    );\n  };\n\n  displayCheckBox(arrayValues, id) {\n    let arrayCheckBoxes = [];\n\n    for (let i = 0; i <= 8; i++) {\n      arrayCheckBoxes.push(\n        <div key={`${id}${i}`} className=\"custom-control custom-switch\">\n          <input\n            type=\"checkbox\"\n            className=\"custom-control-input\"\n            checked={arrayValues[i]}\n            readOnly\n          />\n\n          <label\n            className=\"custom-control-label\"\n            onClick={() => this.updateValuesOptionsRules(id, i)}\n          >\n            {i}\n          </label>\n        </div>\n      );\n    }\n\n    return arrayCheckBoxes;\n  }\n\n  render() {\n    const { speed, variant } = this.props.specific.get();\n    const { size, nbC, nbR } = this.props.core.get();\n\n    return (\n      <form\n        onSubmit={e => e.preventDefault()} // Avoid the submit when click on button\n      >\n        <hr />\n        <h3>Gestion de l'affichage</h3>\n\n        <div className=\"row\">\n          <div className=\"form-group col-4\">\n            <label>Lignes: {nbR}</label>\n            <input\n              className=\"form-control-range\"\n              type=\"range\"\n              value={nbR}\n              min=\"1\"\n              max=\"100\"\n              step=\"1\"\n              onChange={event => this.updateValuesCore(event, \"nbR\")}\n            />\n          </div>\n          <div className=\"form-group col-4\">\n            <label>Colonnes: {nbC}</label>\n            <input\n              className=\"form-control-range\"\n              type=\"range\"\n              value={nbC}\n              min=\"1\"\n              max=\"100\"\n              step=\"1\"\n              onChange={event => this.updateValuesCore(event, \"nbC\")}\n            />\n          </div>\n          <div className=\"form-group col-4\">\n            <label>Taille: {size}</label>\n            <input\n              className=\"form-control-range\"\n              type=\"range\"\n              value={size}\n              min=\"5\"\n              max=\"50\"\n              step=\"1\"\n              onChange={event => this.updateValuesCore(event, \"size\")}\n            />\n          </div>\n        </div>\n\n        <hr />\n        <h3>Gestion de la simulation</h3>\n\n        <div className=\"row no-gutters justify-content-between align-items-center\">\n          <div id=\"SpeedSelection\" className=\"form-group col-5\">\n            <label>Vitesse {speed / 1000}s</label>\n\n            <input\n              className=\"form-control-range\"\n              type=\"range\"\n              value={speed}\n              min=\"100\"\n              max=\"1000\"\n              step=\"100\"\n              onChange={event => this.updateValueSpecific(event, \"speed\")}\n            />\n          </div>\n          <div id=\"buttonsRow\" className=\"row col-6\">\n            {this.playPauseButton()}\n            <button\n              type=\"button\"\n              className={`btn ${BUTTON_COLOR} mx-${MARGIN_BUTTONS} col`}\n              onClick={() => this.props.step()}\n            >\n              Step\n            </button>\n          </div>\n        </div>\n\n        <hr />\n        <h3>Gestion des règles</h3>\n\n        <div className=\"row no-gutters justify-content-between align-items-center\">\n          <div id=\"AutomatonSelection\" className=\"form-group col-5\">\n            <label>Variante du Jeu de la Vie</label>\n            <select\n              className=\"form-control\"\n              value={variant.name}\n              onChange={event => this.updateVariantAutomaton(event)}\n            >\n              {this.displayOptionsFromList(TYPE_GAME_OF_LIFE)}\n            </select>\n          </div>\n\n          <div className=\"row col-6\">\n            <button\n              type=\"button\"\n              className={`btn ${BUTTON_COLOR} mx-${MARGIN_BUTTONS} col`}\n              onClick={() => this.props.clear()}\n            >\n              Vider\n            </button>\n            <button\n              type=\"button\"\n              className={`btn ${BUTTON_COLOR} mx-${MARGIN_BUTTONS} col`}\n              onClick={() => this.props.randomCells()}\n            >\n              Aléatoire\n            </button>\n          </div>\n\n          <div className=\"col-7\">\n            <h4>Cellule nait</h4>\n            {this.displayCheckBox(variant.rules.born, \"born\")}\n          </div>\n\n          <div className=\"col-5\">\n            <h4>Cellule survit</h4>\n            {this.displayCheckBox(variant.rules.survive, \"survive\")}\n          </div>\n\n          <h5>Selection du nombre de voisins vivants nécessaire</h5>\n        </div>\n      </form>\n    );\n  }\n}\n","import React from \"react\";\nimport \"./Bloc.css\";\n\nimport { NB_COLORS } from \"../constantes/constantes\";\n\nexport default class Bloc extends React.Component {\n  createClass() {\n    // Change the class of the bloc\n    const value = this.props.value;\n    if (0 <= value && value < NB_COLORS) {\n      // To make sure the color is set in the CSS file\n      return `active${value}`;\n    } else {\n      console.error(\"Error in the value of the cell\");\n    }\n  }\n\n  render() {\n    const { indR, indC } = this.props.position; // Coordinates of the bloc. Info to send to the parent\n    const size = this.props.size; // Dimension of the bloc to display\n\n    const styles = {\n      height: `${size}px`,\n      width: `${size}px`\n    }; // Size of the bloc\n\n    return (\n      <div\n        // When events are detected, call the parent function\n        onClick={() => this.props.handleClic(indR, indC)} // Event for click -> set the change\n        onMouseEnter={() => this.props.handleEnter(indR, indC)} // If the mouse is inside a bloc\n        className={\"bloc \" + this.createClass()} // Class of bloc + active or not\n        style={styles}\n      >\n        {/* {this.props.value} */}\n      </div>\n    );\n  }\n}\n","/* Functions use to handle the Map */\nexport const getKeyFromCoordinates = (r, c) => {\n  // Return the value of the key for a cell at coordinates (c,r)\n  return `R${r}C${c}`;\n};\n\nexport const getCoordinatesFromKey = key => {\n  // Return the value of the coordinates (c,r) from a key\n  // Return is an object\n  // The key is a string\n\n  let i = 1; // The first value is 'R'\n  let indR = \"\";\n  let indC = \"\";\n\n  while (key[i] !== \"C\") {\n    indR = indR + key[i];\n    i++;\n  }\n\n  i += 1; // Skip 'C\"\n\n  for (; i < key.length; i++) {\n    indC = indC + key[i];\n  }\n\n  //Convert the string value into integer\n  indR = parseInt(indR, 10);\n  indC = parseInt(indC, 10);\n\n  return { indR: indR, indC: indC };\n};\n\nexport const getValueCell = (indR, indC, map) => {\n  // Return the value that correspond to the coordinates\n  const value = map.get(getKeyFromCoordinates(indR, indC));\n\n  if (value === undefined) {\n    // The value is not set so the cell is dead\n    return 0;\n  }\n  return value;\n};\n","import React from \"react\";\nimport Bloc from \"./Bloc\";\n\nimport { getValueCell } from \"../constantes/utilities\";\n\nexport default class Windows extends React.Component {\n  handleEnterNewBloc = (indR, indC) => {\n    // Function call by the children\n    // (indC, indR) are the coordinates of the cell\n    // indR -> value of the row\n    // indC -> value of the column\n    // If the user is clicking, change the value of the calling bloc on enter\n    const click = this.props.specific.get().click;\n\n    if (click) {\n      this.props.changeValueCell(indR, indC);\n    }\n  };\n\n  handleUserClicInsideBloc = (indR, indC) => {\n    // Function call by the children\n    // (indC, indR) are the coordinates of the cell\n    // indR -> value of the row\n    // indC -> value of the column\n    // Handle is the user is clicking inside a bloc\n\n    let nextState = this.props.specific.get();\n\n    nextState.click = !nextState.click;\n    if (nextState.click) {\n      // We need to change the current value of the bloc\n      this.props.changeValueCell(indR, indC, nextState);\n    }\n  };\n\n  displayBlocs() {\n    // return the board to display\n    const { size, nbR, nbC } = this.props.core.get();\n    const { cells } = this.props.specific.get();\n\n    let arrayBlocs = []; // Array of blocs\n    let tmpRow = [];\n    let value; // value of the cell\n\n    for (let r = 0; r < nbR; r++) {\n      tmpRow = [];\n\n      for (let c = 0; c < nbC; c++) {\n        // Iterate over the columns\n\n        value = getValueCell(r, c, cells); // value of the cell\n\n        tmpRow.push(\n          <Bloc\n            key={`R${r}C${c}`}\n            position={{ indR: r, indC: c }}\n            value={value}\n            handleClic={this.handleUserClicInsideBloc}\n            handleEnter={this.handleEnterNewBloc}\n            size={size}\n          />\n        );\n      }\n\n      arrayBlocs.push(\n        <div\n          className=\"d-flex justify-content-center align-items-center\"\n          key={`R${r}`}\n        >\n          {tmpRow}\n        </div>\n      );\n    }\n\n    return arrayBlocs;\n  }\n\n  render() {\n    return <div>{this.displayBlocs()}</div>;\n  }\n}\n","import { Automaton } from \"./Automaton\";\n\nexport class GameOfLife extends Automaton {\n  constructor(map, nbR, nbC, rules) {\n    super(map, 2, nbR, nbC); // The game of life has always 2 states\n\n    this.born = rules.born;\n    this.survive = rules.survive;\n  }\n\n  rules(indR, indC) {\n    // (indC, indR) are the coordinates of the cell\n    // indR -> value of the row\n    // indC -> value of the column\n    // Return the next state of the cell based on the simulation variant\n    const cellValue = this.getValueCell(indR, indC);\n    const neighbour = this.countNeighbours(indR, indC, 1); // Count the cells alive\n\n    const nextCell = this.ruleForCell(cellValue, neighbour); // NextState of the cell\n\n    return nextCell;\n  }\n\n  ruleForCell(cState, neighbour) {\n    if (cState === 0) {\n      // the cell can born\n      if (this.born[neighbour]) {\n        return 1;\n      }\n      return 0;\n    }\n    // the cell can survive\n    else {\n      if (this.survive[neighbour]) {\n        return 1;\n      }\n      return 0;\n    }\n  }\n}\n","import {\n  getKeyFromCoordinates,\n  getCoordinatesFromKey,\n  getValueCell\n} from \"../../constantes/utilities\";\n\nexport class Automaton {\n  constructor(map, nbStates, nbR, nbC) {\n    // Map contains the board\n    // nbStates number of state of the automaton\n    // nbR, nbC size of the board\n    // two functions to handle key in the map\n\n    this.map = map; // Matrix is use as reference\n    this.nbStates = nbStates; // Nb of states in the simulation\n\n    this.nbR = nbR; // Number of rows\n    this.nbC = nbC; // Number of columns\n  }\n\n  getValueCell(indR, indC) {\n    // Return the value of the cell at coordinates (indC, indR)\n\n    return getValueCell(indR, indC, this.map);\n  }\n\n  randomBoard() {\n    // Init a board with random state for the cell\n    // Return the map of the new values\n    let nMap = new Map();\n\n    let key = null; // Key in the map\n    let value = null; // value in the map\n\n    for (let r = 0; r < this.nbR; r++) {\n      // Iterate over the board\n      for (let c = 0; c < this.nbC; c++) {\n        key = getKeyFromCoordinates(r, c);\n        value = Math.floor(Math.random() * Math.floor(this.nbStates));\n\n        if (value !== 0) {\n          // We only store alive cells\n          nMap.set(key, value);\n        }\n      }\n    }\n\n    this.map = nMap; // update the new map reference\n\n    return nMap;\n  }\n\n  next() {\n    // Compute the next state of the simulation\n    let nMap = new Map();\n\n    let cValue; // value of the next state of the cell\n    let cKey; // key to store in the map\n\n    this.map.forEach((value, key) => {\n      // Iterate over all alive cells\n      const { indR, indC } = getCoordinatesFromKey(key);\n\n      // Iterate over the neighboors\n      for (let r = indR - 1; r <= indR + 1; r++) {\n        for (let c = indC - 1; c <= indC + 1; c++) {\n          cValue = this.rules(r, c);\n          if (cValue !== 0) {\n            // Only store alive cell\n            cKey = getKeyFromCoordinates(r, c);\n\n            nMap.delete(cKey); // in case the cell was already visited\n            nMap.set(cKey, cValue);\n          }\n        }\n      }\n    });\n\n    this.map = nMap; // update the new map reference\n\n    return nMap;\n  }\n\n  rules(indR, indC) {\n    // (indC, indR) are the coordinates of the cell\n    // indR -> value of the row\n    // indC -> value of the column\n    // Define all the rules of the simulation\n    // Kind of abstract method\n    // Define in the children\n    // Return the next state of the cell\n  }\n\n  changeValue(indR, indC) {\n    // (indC, indR) are the coordinates of the cell\n    // indR -> value of the row\n    // indC -> value of the column\n    // Return the next value of the cell\n    // Circular change\n\n    return (this.getValueCell(indR, indC) + 1) % this.nbStates;\n  }\n\n  countNeighbours(indR, indC, vToCheck) {\n    // (indC, indR) are the coordinates of the cell\n    // vToCheck is the state of the neighbour to check\n\n    // Values to iterate (ie Neighboors)\n\n    let compt = 0;\n    let cVal; // We can just look at the map. Because 0 aren't store\n\n    // Iterate over the neighboors\n    for (let r = indR - 1; r <= indR + 1; r++) {\n      for (let c = indC - 1; c <= indC + 1; c++) {\n        if (r !== indR || c !== indC) {\n          // We don't count the cell itself\n          cVal = this.getValueCell(r, c);\n          if (cVal === vToCheck) {\n            // Count the state of the cell\n            compt += 1;\n          }\n        }\n      }\n    }\n\n    return compt;\n  }\n}\n","import React from \"react\";\n\n/* React Component */\n\nimport Controls from \"./Controls\";\nimport Windows from \"../Display/Windows\";\n\n/* Automaton */\n\nimport { GameOfLife } from \"./Algo/GameOfLife\";\n\n/* Constantes */\n\nimport {\n  /* Use for the state */\n  INIT_CONTROLS,\n  INIT_CORE,\n  INIT_WINDOWS\n} from \"../constantes/constantes\";\nimport { getKeyFromCoordinates } from \"../constantes/utilities\";\n\nexport default class CellularGame extends React.Component {\n  // CellularGame contains the state of the controls and Windows sections\n  constructor(props) {\n    super(props);\n\n    this.automaton = null; // Contains the logic of the simulation\n    this.animation = null; // Use to animate the simulation\n\n    this.state = {\n      controls: {\n        // State of the controls part\n        ...INIT_CONTROLS\n      },\n      windows: {\n        // State of the windows part\n        ...INIT_WINDOWS\n      },\n      core: {\n        // Shared state\n        ...INIT_CORE\n      }\n    };\n  }\n\n  /* Life cycle component */\n\n  componentDidMount() {\n    // When the component mount,\n    this.initAutomaton(); // Init the automaton for the first time\n  }\n\n  /* Animation part */\n\n  stopAnimation = () => {\n    // Stop the animation of the simulation\n    if (this.animation !== null) {\n      // the animation is set\n      clearInterval(this.animation);\n      this.animation = null;\n    }\n  };\n\n  startAnimation = () => {\n    // Start the animation of the simulation\n    this.animation = setInterval(this.stepAutomaton, this.state.controls.speed);\n  };\n\n  changeValueAnimation = () => {\n    // Use when the user change the value of animation will the animation is playing\n    if (this.animation !== null) {\n      // The animation is currently play\n      this.stopAnimation();\n      this.startAnimation();\n    }\n  };\n\n  handlePlayPause = () => {\n    // Call by controls when the user hit the play/pause button\n    if (this.animation === null) {\n      // Create a new animation at a specific speed\n      this.startAnimation();\n    } else {\n      // The user wants to stop the animation\n      this.stopAnimation();\n    }\n\n    let controls = this.getStateControls();\n    controls.play = !controls.play;\n    this.setStateControls(controls);\n  };\n\n  /* Automaton part */\n\n  initAutomaton = () => {\n    // Init the automaton\n    // Init once even if the matrix change\n    // The matrix use by the Automaton is a reference to the cells in the state\n    this.automaton = new GameOfLife(\n      this.state.windows.cells,\n      this.state.core.nbR,\n      this.state.core.nbC,\n      this.state.controls.variant.rules\n    );\n  };\n\n  stepAutomaton = () => {\n    // Compute the next state\n\n    let nextStateWindows = this.getStateWindows();\n    nextStateWindows.cells = this.automaton.next(); // Compute the next state of the cells\n\n    this.setStateWindows(nextStateWindows);\n  };\n\n  /* Functions to use the board has Map */\n\n  getNewValue = (indR, indC) => {\n    // Get the new value of the cell on click (or enter)\n    // indR -> value of the row\n    // indC -> value of the column\n    // (indC, indR) are the coordinates of the cell\n    return this.automaton.changeValue(indR, indC);\n  };\n\n  changeValueCell = (indR, indC, stateWindows = null) => {\n    // Change the value of the cell and set the new state\n    // (indC, indR) are the coordinates of the cell\n    // indR -> value of the row\n    // indC -> value of the column\n    let newState = stateWindows;\n    if (newState === null) {\n      // If there is a modification is the state, avoid multiple set\n      newState = this.getStateWindows();\n    }\n\n    const value = this.getNewValue(indR, indC); // Change the value of the cell\n    const key = getKeyFromCoordinates(indR, indC);\n\n    newState.cells.delete(key); // remove the previous value (if it is store)\n\n    if (value !== 0) {\n      // Don't store dead cell\n      newState.cells.set(key, value); // store the new value\n    }\n\n    this.setStateWindows(newState);\n  };\n\n  /* Functions to set up the board */\n\n  clearCells = () => {\n    // Set the matrix with 0\n    let newState = this.state;\n\n    newState.windows.cells = this.emptyCells();\n    this.initAutomaton();\n\n    this.setState(newState);\n  };\n\n  emptyCells = () => {\n    // Init all the cells at 0 in the board\n    return new Map();\n  };\n\n  randomCells = () => {\n    let nextState = this.getStateWindows();\n    nextState.cells = this.automaton.randomBoard();\n\n    this.setStateWindows(nextState);\n  };\n\n  /* Setter of the state */\n\n  setStateCore = newCore => {\n    // Set the state of the core part\n    let nextState = this.state;\n    let callBack = undefined;\n\n    if (\n      nextState.core.nbC !== newCore.nbC ||\n      nextState.core.nbR !== newCore.nbR\n    ) {\n      // The size of the board changed\n      callBack = this.initAutomaton; // Clear the previous automaton because dimensions are differents\n    }\n\n    nextState.core = newCore;\n\n    this.setState(nextState, callBack);\n  };\n\n  setStateWindows = newWindows => {\n    // Set the state of the windows part\n    let nextState = this.state;\n    nextState.windows = newWindows;\n    this.setState(nextState);\n  };\n\n  setStateControls = newControls => {\n    // Set the state of the controls part\n\n    let nextState = this.state;\n    let callBack = undefined; // Only one call back is possible according to the control construction\n\n    if (nextState.controls.speed !== newControls.speed) {\n      // the value of the animation changed\n      callBack = this.changeValueAnimation;\n    }\n\n    if (\n      nextState.controls.variant.name !== newControls.variant.name ||\n      // the value of the rules changed\n      nextState.controls.variant.rules !== newControls.variant.rules\n      // The user change options of the automaton\n    ) {\n      callBack = this.initAutomaton;\n    }\n\n    nextState.controls = newControls;\n\n    this.setState(nextState, callBack); // set the state and callback on specific changed\n  };\n\n  /* Getter of the state */\n\n  getCoreState = () => {\n    // Get the state of the core part\n    return this.state.core;\n  };\n\n  getStateWindows = () => {\n    // Get the state of the windows part\n    return this.state.windows;\n  };\n\n  getStateControls = () => {\n    // Get the state of the controls part\n    return this.state.controls;\n  };\n\n  render() {\n    return (\n      <div>\n        <h1>Automate Cellulaire</h1>\n\n        <div>\n          <h2>Nombre de cellules: {this.state.windows.cells.size}</h2>\n        </div>\n\n        <Windows\n          specific={{\n            get: this.getStateWindows,\n            set: this.setStateWindows\n          }}\n          core={{\n            get: this.getCoreState,\n            set: this.setStateCore\n          }}\n          changeValueCell={this.changeValueCell}\n        />\n\n        <Controls\n          specific={{\n            get: this.getStateControls,\n            set: this.setStateControls\n          }}\n          core={{\n            get: this.getCoreState,\n            set: this.setStateCore\n          }}\n          play={this.handlePlayPause}\n          step={this.stepAutomaton}\n          clear={this.clearCells}\n          randomCells={this.randomCells}\n        />\n      </div>\n    );\n  }\n}\n","import React from \"react\";\nimport CellularGame from \"./Logic/CellularGame\";\n\nfunction App() {\n  return (\n    <main className=\"container\">\n      <CellularGame />\n    </main>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}